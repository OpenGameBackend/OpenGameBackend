{
"sdk/typescript/runtime.ts":"/* tslint:disable */\n/* eslint-disable */\n\nexport interface ConfigurationParameters {\n\tendpoint: string; // override base path\n\ttoken?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security\n\theaders?: HTTPHeaders; //header params we want to use on every request\n}\n\nexport class Configuration {\n\tconstructor(private configuration: ConfigurationParameters) {}\n\n\tget endpoint(): string {\n\t\treturn this.configuration.endpoint;\n\t}\n\n\tget token(): ((name: string) => string | Promise<string>) | undefined {\n\t\tconst token = this.configuration.token;\n\t\tif (token) {\n\t\t\treturn typeof token === \"function\" ? token : () => token;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget headers(): HTTPHeaders | undefined {\n\t\treturn this.configuration.headers;\n\t}\n}\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n\tconstructor(protected configuration: Configuration) {\n\t}\n\n\tprotected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {\n\t\tconst { url, init } = await this.createFetchParams(context, initOverrides);\n\t\tconst response = await this.fetchApi(url, init);\n\n\t\tif (response && (response.status >= 200 && response.status < 300)) {\n\t\t\treturn response;\n\t\t}\n\n\t\tif (!response) throw new RequestError(\"No response received\");\n\n\t\tswitch (response.status) {\n\t\t\tcase 500:\n\t\t\t\tthrow new InternalError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 429:\n\t\t\t\tthrow new RateLimitError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 403:\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 408:\n\t\t\t\tthrow new UnauthorizedError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 404:\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 400:\n\t\t\t\tthrow new BadRequestError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new RequestError(undefined, undefined, await parseErrorBody(response));\n\t\t}\n\t}\n\n\tprivate async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {\n\t\tconst url = this.configuration.endpoint + context.path;\n\n\t\tconst headers = Object.assign({}, this.configuration.headers, context.headers);\n\t\tObject.keys(headers).forEach((key) => headers[key] === undefined ? delete headers[key] : {});\n\n\t\tconst initOverrideFn = typeof initOverrides === \"function\" ? initOverrides : async () => initOverrides;\n\n\t\tconst initParams = {\n\t\t\tmethod: context.method,\n\t\t\theaders,\n\t\t\tbody: context.body,\n\t\t};\n\n\t\tconst overriddenInit: RequestInit = {\n\t\t\t...initParams,\n\t\t\t...(await initOverrideFn({\n\t\t\t\tinit: initParams,\n\t\t\t\tcontext,\n\t\t\t})),\n\t\t};\n\n\t\tconst body = JSON.stringify(overriddenInit.body);\n\t\tconst init: RequestInit = {\n\t\t\t...overriddenInit,\n\t\t\tbody,\n\t\t};\n\n\t\treturn { url, init };\n\t}\n\n\tprivate fetchApi = async (url: string, init: RequestInit) => {\n\t\tconst fetchParams = { url, init };\n\t\tlet response: Response | undefined = undefined;\n\t\ttry {\n\t\t\tresponse = await fetch(fetchParams.url, fetchParams.init);\n\t\t} catch (err) {\n\t\t\tthrow new RequestError(\"Failed to make request\", undefined, undefined, { cause: err });\n\t\t}\n\t\treturn response;\n\t};\n}\n\nexport class RequestError extends Error {\n\tconstructor(message?: string, readonly statusCode?: number, readonly body?: unknown, options?: ErrorOptions) {\n\t\tsuper(buildMessage(message, statusCode, body), options);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, RequestError.prototype);\n\t}\n}\n\nexport class InternalError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"InternalError\",\n\t\t\t500,\n\t\t\tbody,\n\t\t);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class RateLimitError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"RateLimitError\",\n\t\t\t429,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class ForbiddenError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"ForbiddenError\",\n\t\t\t403,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class UnauthorizedError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"UnauthorizedError\",\n\t\t\t408,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class NotFoundError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"NotFoundError\",\n\t\t\t404,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class BadRequestError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"BadRequestError\",\n\t\t\t400,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nfunction buildMessage(\n\tmessage: string | undefined,\n\tstatusCode: number | undefined,\n\tbody: unknown | undefined,\n): string {\n\tconst lines: string[] = [];\n\n\tif (message != null) {\n\t\tlines.push(message);\n\t}\n\tif (statusCode != null) {\n\t\tlines.push(`Status code: ${statusCode.toString()}`);\n\t}\n\tif (body != null) {\n\t\tlines.push(`Body: ${JSON.stringify(body, undefined, 2)}`);\n\t}\n\n\treturn lines.join(\"\\n\");\n}\n\nasync function parseErrorBody(response: Response) {\n\treturn await response.json();\n}\n\nexport type FetchAPI = WindowOrWorkerGlobalScope[\"fetch\"];\n\nexport type Json = any;\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\";\nexport type HTTPHeaders = { [key: string]: string };\nexport type HTTPQuery = {\n\t[key: string]:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery;\n};\nexport type HTTPBody = Json | FormData | URLSearchParams;\nexport type HTTPRequestInit = {\n\theaders?: HTTPHeaders;\n\tmethod: HTTPMethod;\n\tcredentials?: RequestCredentials;\n\tbody?: HTTPBody;\n};\nexport type ModelPropertyNaming = \"camelCase\" | \"snake_case\" | \"PascalCase\" | \"original\";\n\nexport type InitOverrideFunction = (\n\trequestContext: { init: HTTPRequestInit; context: RequestOpts },\n) => Promise<RequestInit>;\n\nexport interface FetchParams {\n\turl: string;\n\tinit: RequestInit;\n}\n\nexport interface RequestOpts {\n\tpath: string;\n\tmethod: HTTPMethod;\n\theaders: HTTPHeaders;\n\tquery?: HTTPQuery;\n\tbody?: HTTPBody;\n}\n\nexport function querystring(params: HTTPQuery, prefix: string = \"\"): string {\n\treturn Object.keys(params)\n\t\t.map((key) => querystringSingleKey(key, params[key], prefix))\n\t\t.filter((part) => part.length > 0)\n\t\t.join(\"&\");\n}\n\nfunction querystringSingleKey(\n\tkey: string,\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| undefined\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery,\n\tkeyPrefix: string = \"\",\n): string {\n\tconst fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n\tif (value instanceof Array) {\n\t\tconst multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue)))\n\t\t\t.join(`&${encodeURIComponent(fullKey)}=`);\n\t\treturn `${encodeURIComponent(fullKey)}=${multiValue}`;\n\t}\n\tif (value instanceof Set) {\n\t\tconst valueAsArray = Array.from(value);\n\t\treturn querystringSingleKey(key, valueAsArray, keyPrefix);\n\t}\n\tif (value instanceof Date) {\n\t\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n\t}\n\tif (value instanceof Object) {\n\t\treturn querystring(value as HTTPQuery, fullKey);\n\t}\n\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\n\nexport function mapValues(data: any, fn: (item: any) => any) {\n\treturn Object.keys(data).reduce(\n\t\t(acc, key) => ({ ...acc, [key]: fn(data[key]) }),\n\t\t{},\n\t);\n}\n"
}