{
"sdk\\godot\\client\\client.gd":"extends Node\r\nclass_name BackendClient\r\n## Low-level API used to build HTTP requests to the backend.\r\n\r\nconst _ApiRequest := preload(\"request.gd\")\r\n\r\nvar configuration: BackendConfiguration\r\n\r\nfunc _init(configuration: BackendConfiguration):\r\n\tself.configuration = configuration\r\n\r\n## Builds the headers for a request\r\nfunc _build_headers() -> PackedStringArray:\r\n\treturn [\r\n\t\t\"Accept: application/json\",\r\n\t\t\"Content-Type: application/json\",\r\n\t]\r\n\r\n## Builds the complete URL to the backend\r\nfunc _build_url(path: String) -> String:\r\n\tvar path_segments := path.split(\"/\", false)\r\n\treturn self.configuration.endpoint + \"/\" + \"/\".join(path_segments)\r\n\r\n## Creates a request\r\nfunc build_request(method: HTTPClient.Method, path: String, body: Dictionary) -> _ApiRequest:\r\n\tif !self.is_inside_tree():\r\n\t\tpush_error(\"BackendClient node not added to tree, cannot make http requests\")\r\n\r\n\tvar url := self._build_url(path)\r\n\tvar body_json := JSON.stringify(body)\r\n\r\n\treturn _ApiRequest.new(self, method, url, { \r\n\t\t\"headers\": self._build_headers(), \r\n\t\t\"body\": body_json,\r\n\t})\r\n",
"sdk\\godot\\client\\configuration.gd":"class_name BackendConfiguration\r\n## Backend configuration.\r\n\r\n## Endpoint to send requests to.\r\nvar endpoint: String = \"http://localhost:6420\"\r\n\r\n## The version of the game.\r\nvar game_version: String = \"unknown\"\r\n\r\nfunc _init():\r\n\tself.endpoint = _get_backend_endpoint()\r\n\tBackendLogger.log('Endpoint: %s' % self.endpoint)\r\n\tself.game_version = _get_game_version()\r\n\tBackendLogger.log('Game version: %s' % self.game_version)\r\n\r\n## Path of the configuration file bundled with a game from Rivet.\r\n##\r\n## This file is generated on deploy.\r\nconst RIVET_DEPLOYED_CONFIGURATION_FILE_PATH: String = \"res://.rivet_config.gd\"\r\n\r\n## Path of the configuration file when developing locally.\r\n##\r\n## This file is usually gitignored.\r\nconst RIVET_LOCAL_CONFIGURATION_FILE_PATH: String = \"res://.rivet/config.gd\"\r\n\r\n## Dynamically loads the configuration file with the backend endpoint.\r\nfunc _get_configuration():\r\n\tif FileAccess.file_exists(RIVET_DEPLOYED_CONFIGURATION_FILE_PATH):\r\n\t\tvar deployed_config_file = ResourceLoader.load(RIVET_DEPLOYED_CONFIGURATION_FILE_PATH)\r\n\t\tif deployed_config_file and 'new' in deployed_config_file:\r\n\t\t\tBackendLogger.log('Using endpoint from deployed config')\r\n\t\t\treturn deployed_config_file.new()\r\n\t\r\n\tif FileAccess.file_exists(RIVET_LOCAL_CONFIGURATION_FILE_PATH):\r\n\t\tvar deployed_config_file = ResourceLoader.load(RIVET_LOCAL_CONFIGURATION_FILE_PATH)\r\n\t\tif deployed_config_file and 'new' in deployed_config_file:\r\n\t\t\tBackendLogger.log('Using endpoint from local config')\r\n\t\t\treturn deployed_config_file.new()\r\n\r\n\treturn null\r\n\r\n## Derive the backend endpoint in order of priority:\r\n## - Environment variable (if running from deployed server)\r\n## - Configuration (if running in a client)\r\n## - Fallback to localhost\r\nfunc _get_backend_endpoint():\r\n\t# Use environment variable\r\n\tvar url_env = OS.get_environment(\"BACKEND_ENDPOINT\")\r\n\tif url_env:\r\n\t\tBackendLogger.log('Using endpoint from env')\r\n\t\treturn url_env\r\n\r\n\t# Use configuration shipped with game\r\n\tvar config = _get_configuration()\r\n\tif config:\r\n\t\treturn config.backend_endpoint\r\n\r\n\t# Fallback\r\n\tpush_warning(\"Could not find backend endpoint, falling back to localhost:6420\")\r\n\tBackendLogger.log('Using default endpoint')\r\n\treturn \"http://localhost:6420\"\r\n\r\n## Derive the backend endpoint in order of priority:\r\n## - Environment variable (if running from deployed server)\r\n## - Configuration (if running in a client)\r\n## - Fallback to localhost\r\nfunc _get_game_version():\r\n\t# Use environment variable\r\n\tvar url_env = OS.get_environment(\"GAME_VERSION\")\r\n\tif url_env:\r\n\t\tBackendLogger.log('Using game version from env')\r\n\t\treturn url_env\r\n\r\n\t# Use configuration shipped with game\r\n\tvar config = _get_configuration()\r\n\tif config:\r\n\t\treturn config.game_version\r\n\r\n\t# Fallback\r\n\tpush_warning(\"Could not find game version endpoint\")\r\n\treturn \"unknown\"\r\n\r\n",
"sdk\\godot\\client\\logger.gd":"class_name BackendLogger\r\n\r\nstatic func log(args):\r\n\tprint(\"[Backend] \", args)\r\n\r\nstatic func warning(args):\r\n\tprint(\"[Backend] \", args)\r\n\tpush_warning(\"[Backend] \", args)\r\n\r\nstatic func error(args):\r\n\tprint(\"[Backend] \", args)\r\n\tpush_error(\"[Backend] \", args)\r\n\r\n",
"sdk\\godot\\client\\request.gd":"extends RefCounted\r\nclass_name BackendRequest\r\n## A wrapper around HTTPRequest that emits a signal when the request is completed.\r\n## This is a workaround for the fact that `HTTPRequest.request()` is blocking.\r\n## To run a request, create a new Request, connect to the completed signal,\r\n## and call `request().wait_completed()` to wait for the request to complete.\r\n\r\nconst _ApiResponse := preload(\"response.gd\")\r\n\r\nvar _started_at: int\r\nvar _method: HTTPClient.Method\r\nvar _url: String\r\n\r\nvar response: _ApiResponse = null\r\nvar _opts: Dictionary\r\nvar _http_request: HTTPRequest\r\n\r\nvar _success_callback: Callable\r\nvar _failure_callback: Callable\r\n\r\nsignal completed(response: _ApiResponse)\r\nsignal succeeded(response: _ApiResponse)\r\nsignal failed(response: _ApiResponse)\r\n\r\nfunc _init(owner: Node, method: HTTPClient.Method, url: String, opts: Variant = null):\r\n\tself._started_at = Time.get_ticks_msec()\r\n\tself._method = method\r\n\tself._url = url\r\n\r\n\tself._http_request = HTTPRequest.new()\r\n\tself._http_request.request_completed.connect(_on_request_completed)\r\n\tself._opts = {\r\n\t\t\"method\": method,\r\n\t\t\"url\": url,\r\n\t\t\"body\": opts.body,\r\n\t\t\"headers\": opts.headers,\r\n\t}\r\n\towner.add_child(self._http_request)\r\n\tself._http_request.request(_opts.url, _opts.headers, _opts.method, _opts.body)\r\n\r\nfunc set_success_callback(callback: Callable) -> BackendRequest:\r\n\tself._success_callback = callback\r\n\treturn self\r\n\r\nfunc set_failure_callback(callback: Callable) -> BackendRequest:\r\n\tself._failure_callback = callback\r\n\treturn self\r\n\r\nfunc _on_request_completed(result, response_code, headers, body):\r\n\tself.response = _ApiResponse.new(result, response_code, headers, body)\r\n\r\n\tvar finished_at = Time.get_ticks_msec()\r\n\tvar elapsed = finished_at - self._started_at\r\n\r\n\t# TODO: Print method, but Godot doesn't give method strings\r\n\tvar log_str = \"%s [Result: %s, HTTP: %s, Response: %s, Body: %sB, Elapsed: %sms]\" % [\r\n\t\tself._url,\r\n\t\tBackendResponse.Result.keys()[response.result],\r\n\t\tresponse.http_status,\r\n\t\tresponse.response_code,\r\n\t\tresponse.body_raw.size(),\r\n\t\telapsed,\r\n\t]\r\n\r\n\tif self.response.result == BackendResponse.Result.OK:\r\n\t\tBackendLogger.log(log_str)\r\n\telif self.response.result == BackendResponse.Result.BAD_REQUEST:\r\n\t\tBackendLogger.warning(log_str)\r\n\telse:\r\n\t\tBackendLogger.error(log_str)\r\n\r\n\t# Callbacks\r\n\tif result == OK:\r\n\t\tsucceeded.emit(response)\r\n\t\tif self._success_callback:\r\n\t\t\tself._success_callback.call(response)\r\n\telse:\r\n\t\tfailed.emit(response)\r\n\t\tif self._failure_callback:\r\n\t\t\tself._failure_callback.call(response)\r\n\tcompleted.emit(response)\r\n\r\n## Waits for the request to complete and returns the response in non-blocking way\r\nfunc async() -> _ApiResponse:\r\n\tawait completed\r\n\treturn response\r\n",
"sdk\\godot\\client\\response.gd":"extends RefCounted\r\nclass_name BackendResponse\r\n## A response from the server. Contains the result, response code, headers, and body.\r\n## The body is a dictionary of the JSON response.\r\n\r\nenum Result {\r\n\tOK = 0,\r\n\tBAD_REQUEST = 1,\r\n\tINTERNAL_ERROR = 2,\r\n\tUNKNOWN_RESPONSE_CODE = 3,\r\n\tHTTP_ERROR = 4,\r\n\tJSON_PARSE_ERROR = 5,\r\n\tUNKNOWN = 6\r\n}\r\n\r\nvar result: Result:\r\n\tget:\r\n\t\tif http_status != HTTPClient.Status.STATUS_DISCONNECTED:\r\n\t\t\treturn Result.HTTP_ERROR\r\n\t\telif response_code >= 500 and response_code < 600:\r\n\t\t\treturn Result.INTERNAL_ERROR\r\n\t\telif response_code >= 400 and response_code < 500:\r\n\t\t\treturn Result.BAD_REQUEST\r\n\t\telif response_code == 200 and response_code < 500:\r\n\t\t\tif body != null:\r\n\t\t\t\treturn Result.OK\r\n\t\t\telse:\r\n\t\t\t\treturn Result.JSON_PARSE_ERROR\r\n\t\telif response_code > 0:\r\n\t\t\treturn Result.UNKNOWN_RESPONSE_CODE\r\n\t\telse:\r\n\t\t\treturn Result.UNKNOWN\r\n\r\n## Low-level HTTP response status cdoe.\r\nvar http_status: HTTPClient.Status\r\n\r\n## HTTP status code from response.\r\nvar response_code: HTTPClient.ResponseCode\r\n\r\n## The headers from the server.\r\nvar headers: PackedStringArray\r\n\r\n## The raw body of the response.\r\nvar body_raw: PackedByteArray\r\n\r\n## The parsed JSON body of the response.\r\n##\r\n## Will be null if failed to parse.\r\nvar body: Variant\r\n\r\nfunc _init(http_status: int, response_code: int, headers: PackedStringArray, response_body: PackedByteArray) -> void:\r\n\tself.http_status = http_status\r\n\tself.response_code = response_code\r\n\tself.headers = headers\r\n\t\r\n\tbody_raw = response_body\r\n\tvar json = JSON.new()\r\n\tvar error = json.parse(response_body.get_string_from_utf8())\r\n\tif error == OK:\r\n\t\tbody = json.get_data()\r\n\r\nfunc is_ok() -> bool:\r\n\treturn self.result == Result.OK\r\n\r\nfunc is_error() -> bool:\r\n\treturn !self.is_ok()\r\n\r\nfunc _to_string() -> String:\r\n\treturn \"BackendResponse [Result: %s, HTTP: %s, Response: %s, Body: %s]\" % [\r\n\t\tResult.keys()[result],\r\n\t\thttp_status,\r\n\t\tresponse_code,\r\n\t\tbody_raw.slice(0, 128).get_string_from_ascii()\r\n\t]\r\n\r\n",
"sdk\\godot\\plugin.cfg":"[plugin]\r\n\r\nname=\"Backend\"\r\ndescription=\"Auto-generated client for Open Game Backend (https://opengb.dev).\"\r\nauthor=\"\"\r\nversion=\"1.0.0\"\r\nscript = \"backend.gd\"\r\n\r\n",
"sdk\\typescript\\runtime.ts":"/* tslint:disable */\r\n/* eslint-disable */\r\n\r\nexport interface ConfigurationParameters {\r\n\tendpoint: string; // override base path\r\n\ttoken?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security\r\n\theaders?: HTTPHeaders; //header params we want to use on every request\r\n}\r\n\r\nexport class Configuration {\r\n\tconstructor(private configuration: ConfigurationParameters) {}\r\n\r\n\tget endpoint(): string {\r\n\t\treturn this.configuration.endpoint;\r\n\t}\r\n\r\n\tget token(): ((name: string) => string | Promise<string>) | undefined {\r\n\t\tconst token = this.configuration.token;\r\n\t\tif (token) {\r\n\t\t\treturn typeof token === \"function\" ? token : () => token;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tget headers(): HTTPHeaders | undefined {\r\n\t\treturn this.configuration.headers;\r\n\t}\r\n}\r\n\r\n/**\r\n * This is the base class for all generated API classes.\r\n */\r\nexport class BaseAPI {\r\n\tconstructor(protected configuration: Configuration) {\r\n\t}\r\n\r\n\tprotected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {\r\n\t\tconst { url, init } = await this.createFetchParams(context, initOverrides);\r\n\t\tconst response = await this.fetchApi(url, init);\r\n\r\n\t\tif (response && (response.status >= 200 && response.status < 300)) {\r\n\t\t\treturn response;\r\n\t\t}\r\n\r\n\t\tif (!response) throw new RequestError(\"No response received\");\r\n\r\n\t\tswitch (response.status) {\r\n\t\t\tcase 500:\r\n\t\t\t\tthrow new InternalError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tcase 429:\r\n\t\t\t\tthrow new RateLimitError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tcase 403:\r\n\t\t\t\tthrow new ForbiddenError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tcase 408:\r\n\t\t\t\tthrow new UnauthorizedError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tcase 404:\r\n\t\t\t\tthrow new NotFoundError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tcase 400:\r\n\t\t\t\tthrow new BadRequestError(\r\n\t\t\t\t\tawait parseErrorBody(response),\r\n\t\t\t\t);\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new RequestError(undefined, undefined, await parseErrorBody(response));\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {\r\n\t\tconst url = this.configuration.endpoint + context.path;\r\n\r\n\t\tconst headers = Object.assign({}, this.configuration.headers, context.headers);\r\n\t\tObject.keys(headers).forEach((key) => headers[key] === undefined ? delete headers[key] : {});\r\n\r\n\t\tconst initOverrideFn = typeof initOverrides === \"function\" ? initOverrides : async () => initOverrides;\r\n\r\n\t\tconst initParams = {\r\n\t\t\tmethod: context.method,\r\n\t\t\theaders,\r\n\t\t\tbody: context.body,\r\n\t\t};\r\n\r\n\t\tconst overriddenInit: RequestInit = {\r\n\t\t\t...initParams,\r\n\t\t\t...(await initOverrideFn({\r\n\t\t\t\tinit: initParams,\r\n\t\t\t\tcontext,\r\n\t\t\t})),\r\n\t\t};\r\n\r\n\t\tconst body = JSON.stringify(overriddenInit.body);\r\n\t\tconst init: RequestInit = {\r\n\t\t\t...overriddenInit,\r\n\t\t\tbody,\r\n\t\t};\r\n\r\n\t\treturn { url, init };\r\n\t}\r\n\r\n\tprivate fetchApi = async (url: string, init: RequestInit) => {\r\n\t\tconst fetchParams = { url, init };\r\n\t\tlet response: Response | undefined = undefined;\r\n\t\ttry {\r\n\t\t\tresponse = await fetch(fetchParams.url, fetchParams.init);\r\n\t\t} catch (err) {\r\n\t\t\tthrow new RequestError(\"Failed to make request\", undefined, undefined, { cause: err });\r\n\t\t}\r\n\t\treturn response;\r\n\t};\r\n}\r\n\r\nexport class RequestError extends Error {\r\n\tconstructor(message?: string, readonly statusCode?: number, readonly body?: unknown, options?: ErrorOptions) {\r\n\t\tsuper(buildMessage(message, statusCode, body), options);\r\n\t\t// Show as `Error`\r\n\t\tObject.setPrototypeOf(this, RequestError.prototype);\r\n\t}\r\n}\r\n\r\nexport class InternalError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"InternalError\",\r\n\t\t\t500,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\t// Show as `Error`\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nexport class RateLimitError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"RateLimitError\",\r\n\t\t\t429,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nexport class ForbiddenError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"ForbiddenError\",\r\n\t\t\t403,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nexport class UnauthorizedError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"UnauthorizedError\",\r\n\t\t\t408,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nexport class NotFoundError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"NotFoundError\",\r\n\t\t\t404,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nexport class BadRequestError extends RequestError {\r\n\tconstructor(body: unknown) {\r\n\t\tsuper(\r\n\t\t\t\"BadRequestError\",\r\n\t\t\t400,\r\n\t\t\tbody,\r\n\t\t);\r\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\r\n\t}\r\n}\r\n\r\nfunction buildMessage(\r\n\tmessage: string | undefined,\r\n\tstatusCode: number | undefined,\r\n\tbody: unknown | undefined,\r\n): string {\r\n\tconst lines: string[] = [];\r\n\r\n\tif (message != null) {\r\n\t\tlines.push(message);\r\n\t}\r\n\tif (statusCode != null) {\r\n\t\tlines.push(`Status code: ${statusCode.toString()}`);\r\n\t}\r\n\tif (body != null) {\r\n\t\tlines.push(`Body: ${JSON.stringify(body, undefined, 2)}`);\r\n\t}\r\n\r\n\treturn lines.join(\"\\n\");\r\n}\r\n\r\nasync function parseErrorBody(response: Response) {\r\n\treturn await response.json();\r\n}\r\n\r\nexport type FetchAPI = WindowOrWorkerGlobalScope[\"fetch\"];\r\n\r\nexport type Json = any;\r\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\";\r\nexport type HTTPHeaders = { [key: string]: string };\r\nexport type HTTPQuery = {\r\n\t[key: string]:\r\n\t\t| string\r\n\t\t| number\r\n\t\t| null\r\n\t\t| boolean\r\n\t\t| Array<string | number | null | boolean>\r\n\t\t| Set<string | number | null | boolean>\r\n\t\t| HTTPQuery;\r\n};\r\nexport type HTTPBody = Json | FormData | URLSearchParams;\r\nexport type HTTPRequestInit = {\r\n\theaders?: HTTPHeaders;\r\n\tmethod: HTTPMethod;\r\n\tcredentials?: RequestCredentials;\r\n\tbody?: HTTPBody;\r\n};\r\nexport type ModelPropertyNaming = \"camelCase\" | \"snake_case\" | \"PascalCase\" | \"original\";\r\n\r\nexport type InitOverrideFunction = (\r\n\trequestContext: { init: HTTPRequestInit; context: RequestOpts },\r\n) => Promise<RequestInit>;\r\n\r\nexport interface FetchParams {\r\n\turl: string;\r\n\tinit: RequestInit;\r\n}\r\n\r\nexport interface RequestOpts {\r\n\tpath: string;\r\n\tmethod: HTTPMethod;\r\n\theaders: HTTPHeaders;\r\n\tquery?: HTTPQuery;\r\n\tbody?: HTTPBody;\r\n}\r\n\r\nexport function querystring(params: HTTPQuery, prefix: string = \"\"): string {\r\n\treturn Object.keys(params)\r\n\t\t.map((key) => querystringSingleKey(key, params[key], prefix))\r\n\t\t.filter((part) => part.length > 0)\r\n\t\t.join(\"&\");\r\n}\r\n\r\nfunction querystringSingleKey(\r\n\tkey: string,\r\n\tvalue:\r\n\t\t| string\r\n\t\t| number\r\n\t\t| null\r\n\t\t| undefined\r\n\t\t| boolean\r\n\t\t| Array<string | number | null | boolean>\r\n\t\t| Set<string | number | null | boolean>\r\n\t\t| HTTPQuery,\r\n\tkeyPrefix: string = \"\",\r\n): string {\r\n\tconst fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\r\n\tif (value instanceof Array) {\r\n\t\tconst multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue)))\r\n\t\t\t.join(`&${encodeURIComponent(fullKey)}=`);\r\n\t\treturn `${encodeURIComponent(fullKey)}=${multiValue}`;\r\n\t}\r\n\tif (value instanceof Set) {\r\n\t\tconst valueAsArray = Array.from(value);\r\n\t\treturn querystringSingleKey(key, valueAsArray, keyPrefix);\r\n\t}\r\n\tif (value instanceof Date) {\r\n\t\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\r\n\t}\r\n\tif (value instanceof Object) {\r\n\t\treturn querystring(value as HTTPQuery, fullKey);\r\n\t}\r\n\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\r\n}\r\n\r\nexport function mapValues(data: any, fn: (item: any) => any) {\r\n\treturn Object.keys(data).reduce(\r\n\t\t(acc, key) => ({ ...acc, [key]: fn(data[key]) }),\r\n\t\t{},\r\n\t);\r\n}\r\n"
}