{
"sdk/godot/client/api_client.gd":"extends Node\nclass_name ApiClient\n\nconst _Configuration := preload(\"configuration.gd\")\nconst _ApiRequest := preload(\"request.gd\")\n\nvar configuration: _Configuration\n\nfunc _init(configuration: _Configuration):\n\tself.configuration = configuration\n\n## Builds the headers for a request\nfunc _build_headers() -> PackedStringArray:\n\treturn [\n\t\t\"Accept: application/json\",\n\t\t\"Content-Type: application/json\",\n\t]\n\n## Builds the complete URL to the backend\nfunc _build_url(path: String) -> String:\n\tvar path_segments := path.split(\"/\", false)\n\treturn self.configuration.endpoint + \"/\" + \"/\".join(path_segments)\n\n## Creates a request\nfunc _request(method: HTTPClient.Method, path: String, body: Dictionary) -> _ApiRequest:\n\tif !self.is_inside_tree():\n\t\tpush_error(\"ApiClient node not added to tree, cannot make http requests\")\n\n\tvar url := self._build_url(path)\n\tvar body_json := JSON.stringify(body)\n\n\treturn _ApiRequest.new(self, method, url, { \n\t\t\"headers\": self._build_headers(), \n\t\t\"body\": body_json,\n\t})\n",
"sdk/godot/client/configuration.gd":"## API Configuration\nclass_name Configuration\n\nvar endpoint: String\n\nfunc _init(endpoint: String):\n\tself.endpoint = endpoint\n",
"sdk/godot/client/request.gd":"extends RefCounted\n## A wrapper around HTTPRequest that emits a signal when the request is completed.\n## This is a workaround for the fact that `HTTPRequest.request()` is blocking.\n## To run a request, create a new Request, connect to the completed signal,\n## and call `request().wait_completed()` to wait for the request to complete.\n\n\nconst _ApiResponse := preload(\"response.gd\")\nconst _ApiRequest := preload(\"request.gd\")\n\nvar response: _ApiResponse = null\nvar _opts: Dictionary\nvar _http_request: HTTPRequest\n\nvar _success_callback: Callable\nvar _failure_callback: Callable\n\nsignal completed(response: _ApiResponse)\nsignal succeeded(response: _ApiResponse)\nsignal failed(response: _ApiResponse)\n\nfunc _init(owner: Node, method: HTTPClient.Method, url: String, opts: Variant = null):\n\tself._http_request = HTTPRequest.new()\n\tself._http_request.request_completed.connect(_on_request_completed)\n\tself._opts = {\n\t\t\"method\": method,\n\t\t\"url\": url,\n\t\t\"body\": opts.body,\n\t\t\"headers\": opts.headers,\n\t}\n\towner.add_child(self._http_request)\n\tself._http_request.request(_opts.url, _opts.headers, _opts.method, _opts.body)\n\nfunc set_success_callback(callback: Callable) -> _ApiRequest:\n\tself._success_callback = callback\n\treturn self\n\nfunc set_failure_callback(callback: Callable) -> _ApiRequest:\n\tself._failure_callback = callback\n\treturn self\n\nfunc _on_request_completed(result, response_code, headers, body):\n\tself.response = _ApiResponse.new(result, response_code, headers, body)\n\tif result == OK:\n\t\tsucceeded.emit(response)\n\t\tif self._success_callback:\n\t\t\tself._success_callback.call(response)\n\telse:\n\t\tfailed.emit(response)\n\t\tif self._failure_callback:\n\t\t\tself._failure_callback.call(response)\n\tcompleted.emit(response)\n\n## Waits for the request to complete and returns the response in non-blocking way\nfunc wait_completed() -> _ApiResponse:\n\tawait completed\n\treturn response\n",
"sdk/godot/client/response.gd":"extends RefCounted\n## A response from the server. Contains the result, response code, headers, and body.\n## The body is a dictionary of the JSON response.\n## \n## @experimental\n\n## The result of the request. 0 is success, 1 is failure.\nvar result: HTTPClient.Status\n\n## The response code from the server.\nvar response_code: HTTPClient.ResponseCode\n\n## The headers from the server.\nvar headers: PackedStringArray\n\n## The body of the response, as a JSON dictionary, could be a null.\nvar body: Variant\n\nfunc _init(result: int, response_code: int, headers: PackedStringArray, response_body: PackedByteArray) -> void:\n\tself.result = result\n\tself.response_code = response_code\n\tself.headers = headers\n\t\n\tvar json = JSON.new()\n\tjson.parse(response_body.get_string_from_utf8())\n\tbody = json.get_data()\n",
"sdk/godot/plugin.cfg":"[plugin]\n\nname=\"Backend\"\ndescription=\"\"\nauthor=\"\"\nversion=\"0.0.1\"\n",
"sdk/typescript/runtime.ts":"/* tslint:disable */\n/* eslint-disable */\n\nexport interface ConfigurationParameters {\n\tendpoint: string; // override base path\n\ttoken?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security\n\theaders?: HTTPHeaders; //header params we want to use on every request\n}\n\nexport class Configuration {\n\tconstructor(private configuration: ConfigurationParameters) {}\n\n\tget endpoint(): string {\n\t\treturn this.configuration.endpoint;\n\t}\n\n\tget token(): ((name: string) => string | Promise<string>) | undefined {\n\t\tconst token = this.configuration.token;\n\t\tif (token) {\n\t\t\treturn typeof token === \"function\" ? token : () => token;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget headers(): HTTPHeaders | undefined {\n\t\treturn this.configuration.headers;\n\t}\n}\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n\tconstructor(protected configuration: Configuration) {\n\t}\n\n\tprotected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {\n\t\tconst { url, init } = await this.createFetchParams(context, initOverrides);\n\t\tconst response = await this.fetchApi(url, init);\n\n\t\tif (response && (response.status >= 200 && response.status < 300)) {\n\t\t\treturn response;\n\t\t}\n\n\t\tif (!response) throw new RequestError(\"No response received\");\n\n\t\tswitch (response.status) {\n\t\t\tcase 500:\n\t\t\t\tthrow new InternalError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 429:\n\t\t\t\tthrow new RateLimitError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 403:\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 408:\n\t\t\t\tthrow new UnauthorizedError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 404:\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tcase 400:\n\t\t\t\tthrow new BadRequestError(\n\t\t\t\t\tawait parseErrorBody(response),\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new RequestError(undefined, undefined, await parseErrorBody(response));\n\t\t}\n\t}\n\n\tprivate async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {\n\t\tconst url = this.configuration.endpoint + context.path;\n\n\t\tconst headers = Object.assign({}, this.configuration.headers, context.headers);\n\t\tObject.keys(headers).forEach((key) => headers[key] === undefined ? delete headers[key] : {});\n\n\t\tconst initOverrideFn = typeof initOverrides === \"function\" ? initOverrides : async () => initOverrides;\n\n\t\tconst initParams = {\n\t\t\tmethod: context.method,\n\t\t\theaders,\n\t\t\tbody: context.body,\n\t\t};\n\n\t\tconst overriddenInit: RequestInit = {\n\t\t\t...initParams,\n\t\t\t...(await initOverrideFn({\n\t\t\t\tinit: initParams,\n\t\t\t\tcontext,\n\t\t\t})),\n\t\t};\n\n\t\tconst body = JSON.stringify(overriddenInit.body);\n\t\tconst init: RequestInit = {\n\t\t\t...overriddenInit,\n\t\t\tbody,\n\t\t};\n\n\t\treturn { url, init };\n\t}\n\n\tprivate fetchApi = async (url: string, init: RequestInit) => {\n\t\tconst fetchParams = { url, init };\n\t\tlet response: Response | undefined = undefined;\n\t\ttry {\n\t\t\tresponse = await fetch(fetchParams.url, fetchParams.init);\n\t\t} catch (err) {\n\t\t\tthrow new RequestError(\"Failed to make request\", undefined, undefined, { cause: err });\n\t\t}\n\t\treturn response;\n\t};\n}\n\nexport class RequestError extends Error {\n\tconstructor(message?: string, readonly statusCode?: number, readonly body?: unknown, options?: ErrorOptions) {\n\t\tsuper(buildMessage(message, statusCode, body), options);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, RequestError.prototype);\n\t}\n}\n\nexport class InternalError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"InternalError\",\n\t\t\t500,\n\t\t\tbody,\n\t\t);\n\t\t// Show as `Error`\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class RateLimitError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"RateLimitError\",\n\t\t\t429,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class ForbiddenError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"ForbiddenError\",\n\t\t\t403,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class UnauthorizedError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"UnauthorizedError\",\n\t\t\t408,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class NotFoundError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"NotFoundError\",\n\t\t\t404,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nexport class BadRequestError extends RequestError {\n\tconstructor(body: unknown) {\n\t\tsuper(\n\t\t\t\"BadRequestError\",\n\t\t\t400,\n\t\t\tbody,\n\t\t);\n\t\tObject.setPrototypeOf(this, ForbiddenError.prototype);\n\t}\n}\n\nfunction buildMessage(\n\tmessage: string | undefined,\n\tstatusCode: number | undefined,\n\tbody: unknown | undefined,\n): string {\n\tconst lines: string[] = [];\n\n\tif (message != null) {\n\t\tlines.push(message);\n\t}\n\tif (statusCode != null) {\n\t\tlines.push(`Status code: ${statusCode.toString()}`);\n\t}\n\tif (body != null) {\n\t\tlines.push(`Body: ${JSON.stringify(body, undefined, 2)}`);\n\t}\n\n\treturn lines.join(\"\\n\");\n}\n\nasync function parseErrorBody(response: Response) {\n\treturn await response.json();\n}\n\nexport type FetchAPI = WindowOrWorkerGlobalScope[\"fetch\"];\n\nexport type Json = any;\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\";\nexport type HTTPHeaders = { [key: string]: string };\nexport type HTTPQuery = {\n\t[key: string]:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery;\n};\nexport type HTTPBody = Json | FormData | URLSearchParams;\nexport type HTTPRequestInit = {\n\theaders?: HTTPHeaders;\n\tmethod: HTTPMethod;\n\tcredentials?: RequestCredentials;\n\tbody?: HTTPBody;\n};\nexport type ModelPropertyNaming = \"camelCase\" | \"snake_case\" | \"PascalCase\" | \"original\";\n\nexport type InitOverrideFunction = (\n\trequestContext: { init: HTTPRequestInit; context: RequestOpts },\n) => Promise<RequestInit>;\n\nexport interface FetchParams {\n\turl: string;\n\tinit: RequestInit;\n}\n\nexport interface RequestOpts {\n\tpath: string;\n\tmethod: HTTPMethod;\n\theaders: HTTPHeaders;\n\tquery?: HTTPQuery;\n\tbody?: HTTPBody;\n}\n\nexport function querystring(params: HTTPQuery, prefix: string = \"\"): string {\n\treturn Object.keys(params)\n\t\t.map((key) => querystringSingleKey(key, params[key], prefix))\n\t\t.filter((part) => part.length > 0)\n\t\t.join(\"&\");\n}\n\nfunction querystringSingleKey(\n\tkey: string,\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| null\n\t\t| undefined\n\t\t| boolean\n\t\t| Array<string | number | null | boolean>\n\t\t| Set<string | number | null | boolean>\n\t\t| HTTPQuery,\n\tkeyPrefix: string = \"\",\n): string {\n\tconst fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n\tif (value instanceof Array) {\n\t\tconst multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue)))\n\t\t\t.join(`&${encodeURIComponent(fullKey)}=`);\n\t\treturn `${encodeURIComponent(fullKey)}=${multiValue}`;\n\t}\n\tif (value instanceof Set) {\n\t\tconst valueAsArray = Array.from(value);\n\t\treturn querystringSingleKey(key, valueAsArray, keyPrefix);\n\t}\n\tif (value instanceof Date) {\n\t\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n\t}\n\tif (value instanceof Object) {\n\t\treturn querystring(value as HTTPQuery, fullKey);\n\t}\n\treturn `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\n\nexport function mapValues(data: any, fn: (item: any) => any) {\n\treturn Object.keys(data).reduce(\n\t\t(acc, key) => ({ ...acc, [key]: fn(data[key]) }),\n\t\t{},\n\t);\n}\n"
}