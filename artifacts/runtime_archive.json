{
"src/deps.ts":"export {\n\tdirname,\n\tformat as formatPath,\n\tfromFileUrl,\n\tisAbsolute,\n\tparse as parsePath,\n\trelative,\n\tresolve,\n\tSEP,\n} from \"https://deno.land/std@0.208.0/path/mod.ts\";\nexport { copy, emptyDir, exists, move } from \"https://deno.land/std@0.208.0/fs/mod.ts\";\nexport { assert, assertEquals, assertExists } from \"https://deno.land/std@0.208.0/assert/mod.ts\";\n\nexport * as tjs from \"npm:typescript-json-schema@0.62.0\";\n\nimport Ajv from \"https://esm.sh/ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"https://esm.sh/ajv-formats@^2.1.1\";\nexport { addFormats };\n\n// Must match version in `esbuild_deno_loader`\n//\n// See also Prisma esbuild in `src/migrate/deps.ts`\nexport * as esbuild from \"https://deno.land/x/esbuild@v0.20.2/mod.js\";\nexport { denoPlugins } from \"jsr:@luca/esbuild-deno-loader@^0.10.3\";\n\nexport * as glob from \"https://esm.sh/glob@^10.3.10\";\n",
"src/runtime/actor/actor.ts":"import { ModuleContextParams } from \"../context.ts\";\nimport { errorToLogEntries } from \"../logger.ts\";\nimport { ActorContext } from \"../mod.ts\";\nimport { ScheduleDriver, StorageDriver } from \"./driver.ts\";\n\n/**\n * Actor implementation that user-made actors will extend.\n */\nexport abstract class ActorBase<\n\tInput,\n\tState,\n> {\n\tpublic state!: State;\n\n\tprivate backgroundPromises: Promise<void>[] = [];\n\n\tpublic constructor(\n\t\tpublic readonly storage: StorageDriver,\n\t\tpublic readonly schedule: ScheduleDriver,\n\t) {}\n\n\tpublic abstract initialize(ctx: ActorContext<ModuleContextParams>, input: Input): State | Promise<State>;\n\n\t/**\n\t * Runs a promise in the background.\n\t *\n\t * This allows the actor runtime to ensure that a promise completes while\n\t * returning from an RPC request early.\n\t */\n\tprotected runInBackground<Params extends ModuleContextParams>(ctx: ActorContext<Params>, promise: Promise<void>) {\n\t\t// Add logging to promise and make it non-failable\n\t\tconst nonfailablePromise = promise\n\t\t\t.then(() => ctx.log.trace(\"background promise complete\"))\n\t\t\t.catch((err) => ctx.log.error(\"background promise failed\", ...errorToLogEntries(\"error\", err)));\n\n\t\tthis.backgroundPromises.push(nonfailablePromise);\n\t}\n\n\t/**\n\t * Waits for all promises to finish running.\n\t */\n\tpublic async waitForBackgroundPromises() {\n\t\tfor (const promise of this.backgroundPromises) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n",
"src/runtime/actor/driver.ts":"import { Trace } from \"../mod.ts\";\n\nexport interface CreateOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tinput: unknown;\n\ttrace: Trace;\n}\n\nexport interface CallOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\nexport interface GetOrCreateAndCallOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tinput: unknown;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\nexport interface ExistsOpts {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n}\n\nexport interface ActorDriver {\n\tcreateActor(opts: CreateOpts): Promise<void>;\n\tcallActor(opts: CallOpts): Promise<unknown>;\n\tgetOrCreateAndCallActor(opts: GetOrCreateAndCallOpts): Promise<unknown>;\n\tactorExists(opts: ExistsOpts): Promise<boolean>;\n}\n\nexport interface StorageDriver {\n\tget<V>(key: string): Promise<V | undefined>;\n\tput<V>(key: string, value: V): Promise<void>;\n\tdelete(key: string): Promise<void>;\n}\n\nexport interface ScheduleDriver {\n\tafter(duration: number, fn: string, request: unknown): void;\n\tat(timestamp: number, fn: string, request: unknown): void;\n}\n",
"src/runtime/actor/drivers/cloudflare_durable_objects/driver.ts":"// This file is only imported when the runtime is `cloudflare_workers_platform`.\n\nimport { Config } from \"../../../mod.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"../../driver.ts\";\n\nexport class CloudflareDurableObjectsActorDriver implements ActorDriver {\n\tpublic constructor(public readonly config: Config) {}\n\n\tasync createActor(opts: CreateOpts): Promise<void> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\t\treturn await stub.init({\n\t\t\tmodule: opts.moduleName,\n\t\t\tactor: opts.actorName,\n\t\t\tinstance: opts.instanceName,\n\t\t\tinput: opts.input,\n\t\t\ttrace: opts.trace,\n\t\t});\n\t}\n\n\tasync callActor(opts: CallOpts): Promise<unknown> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\n\t\t// HACK: Fixes \"Type instantiation is excessively deep and possibly infinite.\"\n\t\treturn await stub.callRpc({\n\t\t\tfn: opts.fn,\n\t\t\trequest: opts.request,\n\t\t\ttrace: opts.trace,\n\t\t});\n\t}\n\n\tasync getOrCreateAndCallActor(opts: GetOrCreateAndCallOpts): Promise<unknown> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\n\t\t// HACK: Fixes \"Type instantiation is excessively deep and possibly infinite.\"\n\t\treturn await stub.getOrCreateAndCallRpc({\n\t\t\tinit: {\n\t\t\t\tmodule: opts.moduleName,\n\t\t\t\tactor: opts.actorName,\n\t\t\t\tinstance: opts.instanceName,\n\t\t\t\tinput: opts.input,\n\t\t\t\ttrace: opts.trace,\n\t\t\t},\n\t\t\tfn: opts.fn,\n\t\t\trequest: opts.request,\n\t\t\ttrace: opts.trace,\n\t\t});\n\t}\n\n\tasync actorExists(opts: ExistsOpts): Promise<boolean> {\n\t\tconst stub = this.getStub(opts.moduleName, opts.actorName, opts.instanceName);\n\t\treturn await stub.initialized();\n\t}\n\n\tprivate getStub(\n\t\tmoduleName: string,\n\t\tactorName: string,\n\t\tinstanceName: string,\n\t): any {\n\t\t// TODO: Fix Deno.env.get hack. This does not return a string, it returns an object.\n\t\tconst ns = Deno.env.get(\"__GLOBAL_DURABLE_OBJECT\") as any;\n\n\t\tconst module = this.config.modules[moduleName];\n\t\tconst actor = module.actors[actorName];\n\t\tconst name = `%%${module.storageAlias}%%${actor.storageAlias}%%${instanceName}`;\n\t\tconst id = ns.idFromName(name);\n\n\t\treturn ns.get(id);\n\t}\n}\n\nexport { CloudflareDurableObjectsActorDriver as ActorDriver };\n",
"src/runtime/actor/drivers/cloudflare_durable_objects/global_durable_object.ts":"/// <reference types=\"npm:@cloudflare/workers-types\" />\nimport { DurableObject } from \"cloudflare:workers\";\nimport { CloudflareDurableObjectsStorage } from \"./storage.ts\";\nimport { CloudflareDurableObjectsSchedule } from \"./schedule.ts\";\nimport { ActorBase } from \"../../actor.ts\";\nimport {\n\tActor,\n\tActorContext,\n\tappendTraceEntry,\n\tConfig,\n\tModule,\n\tModuleContextParams,\n\tRuntime,\n\tTrace,\n} from \"../../../mod.ts\";\nimport { RegistryCallMap } from \"../../../proxy.ts\";\nimport { ActorDriver } from \"./driver.ts\";\nimport { newTrace } from \"../../../trace.ts\";\nimport { errorToLogEntries, log } from \"../../../logger.ts\";\n\nconst KEYS = {\n\tMETA: {\n\t\tMODULE: \"meta:module\",\n\t\tACTOR: \"meta:module\",\n\t\tCREATED_AT: \"__meta:created_at\",\n\t},\n\tSCHEDULE: {\n\t\tSCHEDULE: \"schedule:schedule\",\n\t\tEVENT_PREFIX: \"schedule:event:\",\n\t\tevent(id: string): string {\n\t\t\treturn `${this.EVENT_PREFIX}${id}`;\n\t\t},\n\t},\n\tSTATE: \"state\",\n};\n\ninterface ScheduleState {\n\t// Sorted by timestamp asc\n\tevents: ScheduleIndexEvent[];\n}\n\ninterface ScheduleIndexEvent {\n\ttimestamp: number;\n\teventId: string;\n}\n\ninterface ScheduleEvent {\n\ttimestamp: number;\n\tfn: string;\n\trequest: unknown;\n}\n\n// MARK: TODO:\ninterface InitOpts {\n\tmodule: string;\n\tactor: string;\n\tinstance: string;\n\tinput: any;\n\ttrace: Trace;\n\tignoreAlreadyInitialized?: boolean;\n}\n\ninterface GetOrCreateAndCallOpts {\n\tinit: InitOpts;\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\ninterface CallRpcOpts {\n\tfn: string;\n\trequest: unknown;\n\ttrace: Trace;\n}\n\n/*\n * __GlobalDurableObject type used for referencing an instance of the class.\n */\nexport interface __GlobalDurableObjectT extends DurableObject {\n\tinit(opts: InitOpts): Promise<void>;\n\tinitialized(): Promise<boolean>;\n\tgetOrCreateAndCallRpc(opts: GetOrCreateAndCallOpts): Promise<any>;\n\tcallRpc({ fn, request }: CallRpcOpts): Promise<any>;\n\tscheduleEvent(timestamp: number, fn: string, request: unknown): Promise<void>;\n\talarm(): Promise<void>;\n\tget storage(): DurableObjectStorage;\n}\n\n/**\n * Actor data & config read from the actor state.\n */\ninterface ActorMeta {\n\tmoduleName: string;\n\tactorName: string;\n\tstate: any;\n}\n\n/**\n * Generate a __GlobalDurableObject class that has access to the current config.\n *\n * We have to pass the config like this since the config's import is\n * dynamically generated in entrypoint.ts.\n *\n * Doing this instead of setting a static `__GlobalDurableObject.config = xxxx`\n * is better since it ensures that you _can't_ create an instance of\n * __GlobalDurableObject that doesn't have an associated config.\n */\nexport function buildGlobalDurableObjectClass(\n\tconfig: Config,\n\tdependencyCaseConversionMap: RegistryCallMap,\n\tactorDependencyCaseConversionMap: RegistryCallMap,\n) {\n\tclass __GlobalDurableObject extends DurableObject implements __GlobalDurableObjectT {\n\t\tprivate runtime: Runtime<ModuleContextParams>;\n\n\t\tconstructor(ctx: DurableObjectState, env: unknown) {\n\t\t\tsuper(ctx, env);\n\n\t\t\tthis.runtime = new Runtime(\n\t\t\t\tconfig,\n\t\t\t\tnew ActorDriver(config),\n\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Reads the metadata related to this actor from storage.\n\t\t *\n\t\t * This data is set in `init`.\n\t\t */\n\t\tasync getMeta(): Promise<ActorMeta> {\n\t\t\t// Create actor instance\n\t\t\tconst storageRes = await this.ctx.storage.get<string>([KEYS.META.MODULE, KEYS.META.ACTOR, KEYS.STATE]);\n\t\t\tconst moduleName = storageRes.get(KEYS.META.MODULE);\n\t\t\tconst actorName = storageRes.get(KEYS.META.ACTOR);\n\t\t\tconst state = storageRes.get(KEYS.STATE);\n\t\t\tif (moduleName == undefined || actorName == undefined) throw new Error(\"actor not initialized\");\n\t\t\tif (state == undefined) throw Error(\"actor state not initiated\");\n\n\t\t\treturn { moduleName, actorName, state };\n\t\t}\n\n\t\t// TODO: optimize to use in-memory state\n\t\tprivate async constructActor(meta: ActorMeta): Promise<ActorBase<unknown, unknown>> {\n\t\t\t// Get actor config\n\t\t\tif (!(meta.moduleName in config.modules)) throw new Error(\"module not found\");\n\t\t\tconst moduleConfig = config.modules[meta.moduleName];\n\t\t\tif (!(meta.actorName in moduleConfig.actors)) throw new Error(\"actor not found\");\n\t\t\tconst actorConfig = moduleConfig.actors[meta.actorName];\n\n\t\t\t// TODO: cache actor instance in memory\n\t\t\t// TODO: use ctx.waitUntil for all calls\n\t\t\t// Run actor function\n\t\t\tconst actor = new (actorConfig.actor)(\n\t\t\t\tnew CloudflareDurableObjectsStorage(this),\n\t\t\t\tnew CloudflareDurableObjectsSchedule(this),\n\t\t\t);\n\n\t\t\treturn actor;\n\t\t}\n\n\t\tprivate createActorContext(moduleName: string, actorName: string, trace: Trace): ActorContext<ModuleContextParams> {\n\t\t\t// Build context\n\t\t\tconst module = config.modules[moduleName];\n\t\t\tconst context = new ActorContext<ModuleContextParams>(\n\t\t\t\tthis.runtime,\n\t\t\t\ttrace,\n\t\t\t\tmoduleName,\n\t\t\t\tthis.runtime.postgres.getOrCreatePrismaClient(this.runtime.config, module),\n\t\t\t\tmodule.db?.schema,\n\t\t\t\tactorName,\n\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t);\n\n\t\t\treturn context;\n\t\t}\n\n\t\tasync init(opts: InitOpts) {\n\t\t\t// Check if already initialized\n\t\t\tif (await this.initialized()) {\n\t\t\t\tif (!opts.ignoreAlreadyInitialized) throw new Error(\"already initialized\");\n\t\t\t}\n\n\t\t\t// Store metadata\n\t\t\tawait this.ctx.storage.put({\n\t\t\t\t[KEYS.META.MODULE]: opts.module,\n\t\t\t\t[KEYS.META.ACTOR]: opts.actor,\n\t\t\t\t[KEYS.META.CREATED_AT]: Date.now(),\n\t\t\t});\n\n\t\t\t// Build initial state\n\t\t\tconst actor = await this.constructActor({\n\t\t\t\tmoduleName: opts.module,\n\t\t\t\tactorName: opts.actor,\n\t\t\t\tstate: undefined,\n\t\t\t});\n\t\t\tconst context = this.createActorContext(\n\t\t\t\topts.module,\n\t\t\t\topts.actor,\n\t\t\t\tappendTraceEntry(opts.trace, { actorInitialize: { module: opts.module, actor: opts.actor } }),\n\t\t\t);\n\t\t\tconst state = actor.initialize(context, opts.input);\n\t\t\tawait this.ctx.storage.put(KEYS.STATE, state);\n\t\t}\n\n\t\tasync initialized() {\n\t\t\treturn await this.ctx.storage.get(KEYS.META.MODULE) != undefined;\n\t\t}\n\n\t\tasync getOrCreateAndCallRpc(opts: GetOrCreateAndCallOpts): Promise<any> {\n\t\t\tawait this.init({\n\t\t\t\t...opts.init,\n\t\t\t\tignoreAlreadyInitialized: true,\n\t\t\t});\n\n\t\t\treturn await this.callRpc({ fn: opts.fn, request: opts.request, trace: opts.trace });\n\t\t}\n\n\t\tasync callRpc({ fn, request, trace }: CallRpcOpts): Promise<any> {\n\t\t\tconst meta = await this.getMeta();\n\t\t\tconst actor = await this.constructActor(meta);\n\t\t\tactor.state = meta.state;\n\n\t\t\tconst context = this.createActorContext(\n\t\t\t\tmeta.moduleName,\n\t\t\t\tmeta.actorName,\n\t\t\t\tappendTraceEntry(trace, { actorCall: { module: meta.moduleName, actor: meta.actorName, fn } }),\n\t\t\t);\n\n\t\t\t// Call fn\n\t\t\tlet callRes = (actor as any)[fn](context, request);\n\t\t\tif (callRes instanceof Promise) callRes = await callRes;\n\n\t\t\t// Update state\n\t\t\tawait this.ctx.storage.put(KEYS.STATE, actor.state);\n\n\t\t\treturn callRes;\n\t\t}\n\n\t\tasync scheduleEvent(timestamp: number, fn: string, request: unknown) {\n\t\t\t// Save event\n\t\t\tconst eventId = crypto.randomUUID();\n\t\t\tawait this.ctx.storage.put<ScheduleEvent>(KEYS.SCHEDULE.event(eventId), {\n\t\t\t\ttimestamp,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t});\n\n\t\t\t// Read index\n\t\t\tconst schedule: ScheduleState = await this.ctx.storage.get(KEYS.SCHEDULE.SCHEDULE) ?? { events: [] };\n\n\t\t\t// Insert event in to index\n\t\t\tconst newEvent: ScheduleIndexEvent = { timestamp, eventId };\n\t\t\tconst insertIndex = schedule.events.findIndex((x) => x.timestamp > newEvent.timestamp);\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tschedule.events.push(newEvent);\n\t\t\t} else {\n\t\t\t\tschedule.events.splice(insertIndex, 0, newEvent);\n\t\t\t}\n\n\t\t\t// Write new index\n\t\t\tawait this.ctx.storage.put(KEYS.SCHEDULE.SCHEDULE, schedule);\n\n\t\t\t// Update alarm if:\n\t\t\t// - this is the newest event (i.e. at beginning of array) or\n\t\t\t// - this is the only event (i.e. the only event in the array)\n\t\t\tif (insertIndex == 0 || schedule.events.length == 1) {\n\t\t\t\tawait this.ctx.storage.setAlarm(newEvent.timestamp);\n\t\t\t}\n\t\t}\n\n\t\tasync alarm() {\n\t\t\tconst now = Date.now();\n\n\t\t\t// Read index\n\t\t\tconst scheduleIndex: ScheduleState = await this.ctx.storage.get(KEYS.SCHEDULE.SCHEDULE) ?? { events: [] };\n\n\t\t\t// Remove events from schedule\n\t\t\tconst runIndex = scheduleIndex.events.findIndex((x) => x.timestamp > now);\n\t\t\tconst scheduleIndexEvents = scheduleIndex.events.splice(0, runIndex + 1);\n\n\t\t\t// Find events to trigger\n\t\t\tconst eventKeys = scheduleIndexEvents.map((x) => KEYS.SCHEDULE.event(x.eventId));\n\t\t\tconst scheduleEvents = await this.ctx.storage.get<ScheduleEvent>(eventKeys);\n\t\t\tawait this.ctx.storage.delete(eventKeys);\n\n\t\t\t// Write new schedule\n\t\t\tawait this.ctx.storage.put(KEYS.SCHEDULE.SCHEDULE, scheduleIndex);\n\n\t\t\t// Set alarm for next event\n\t\t\tif (scheduleIndex.events.length > 0) {\n\t\t\t\tawait this.ctx.storage.setAlarm(scheduleIndex.events[0].timestamp);\n\t\t\t}\n\n\t\t\t// Iterate by event key in order to ensure we call the events in order\n\t\t\tfor (const eventKey of eventKeys) {\n\t\t\t\tconst event = scheduleEvents.get(eventKey)!;\n\t\t\t\ttry {\n\t\t\t\t\t// TODO: how do we handle this promise cleanly?\n\t\t\t\t\tconst res = this.callRpc({ fn: event.fn, request: event.request, trace: newTrace({ actorSchedule: {} }) });\n\t\t\t\t\tif (res instanceof Promise) await res;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlog(\"error\", \"failed to run scheduled event\", [\"fn\", event.fn], ...errorToLogEntries(\"error\", err));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Make storage publicly accessible for use in `StorageDriver`.\n\t\t */\n\t\tpublic get storage(): DurableObjectStorage {\n\t\t\treturn this.ctx.storage;\n\t\t}\n\t}\n\n\treturn __GlobalDurableObject;\n}\n",
"src/runtime/actor/drivers/cloudflare_durable_objects/schedule.ts":"import { ScheduleDriver } from \"../../driver.ts\";\nimport { __GlobalDurableObjectT } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsSchedule implements ScheduleDriver {\n\tconstructor(private readonly durableObject: __GlobalDurableObjectT) {}\n\n\tafter(duration: number, fn: string, request: unknown): void {\n\t\tthis.durableObject.scheduleEvent(Date.now() + duration, fn, request);\n\t}\n\tat(timestamp: number, fn: string, request: unknown): void {\n\t\tthis.durableObject.scheduleEvent(timestamp, fn, request);\n\t}\n}\n",
"src/runtime/actor/drivers/cloudflare_durable_objects/storage.ts":"import { StorageDriver } from \"../../driver.ts\";\nimport { __GlobalDurableObjectT } from \"./global_durable_object.ts\";\n\nexport class CloudflareDurableObjectsStorage implements StorageDriver {\n\tconstructor(private readonly durableObject: __GlobalDurableObjectT) {}\n\n\tasync get<V>(key: string): Promise<V | undefined> {\n\t\tconst jsonRaw = await this.durableObject.storage.get<string>(buildStorageKey(key));\n\t\tif (jsonRaw) {\n\t\t\treturn await JSON.parse(jsonRaw);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\tasync put<V>(key: string, value: V): Promise<void> {\n\t\tawait this.durableObject.storage.put(key, JSON.stringify(value));\n\t}\n\tasync delete(key: string): Promise<void> {\n\t\tawait this.durableObject.storage.delete(buildStorageKey(key));\n\t}\n}\n\n/**\n * Build a key from the actor's API that's namespaced to the storage.\n *\n * This allows us to store metadata on different keys.\n */\nfunction buildStorageKey(key: string): string {\n\treturn `storage:${key}`;\n}\n",
"src/runtime/actor/drivers/memory/driver.ts":"// This file is only imported when the runtime is `deno`\n//\nimport { ModuleContextParams } from \"../../../context.ts\";\nimport { ActorContext, appendTraceEntry, Config, Runtime, Trace, TraceEntry } from \"../../../mod.ts\";\nimport { RegistryCallMap } from \"../../../proxy.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"../../driver.ts\";\nimport { MemorySchedule } from \"./schedule.ts\";\nimport { MemoryStorage } from \"./storage.ts\";\n\nexport interface ActorEntry {\n\tmoduleName: string;\n\tactorName: string;\n\tinstanceName: string;\n\tstate?: string;\n\tstorage: Map<string, string>;\n}\n\nexport class MemoryActorDriver implements ActorDriver {\n\tprivate runtime: Runtime<ModuleContextParams>;\n\tprivate encoder = new TextEncoder();\n\tprivate actorRegistry = new Map<string, ActorEntry>();\n\n\tpublic constructor(\n\t\tpublic readonly config: Config,\n\t\tprivate dependencyCaseConversionMap: RegistryCallMap,\n\t\tprivate actorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.runtime = new Runtime(\n\t\t\tthis.config,\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tasync createActor({ moduleName, actorName, instanceName, input, trace }: CreateOpts): Promise<void> {\n\t\tconst id = await this.getId(moduleName, actorName, instanceName);\n\n\t\t// Ensure doesn't already exist\n\t\tif (this.actorRegistry.has(await this.getId(moduleName, actorName, instanceName))) {\n\t\t\tthrow new Error(\"actor already created\");\n\t\t}\n\n\t\t// Build drivers\n\t\tconst actorEntry: ActorEntry = {\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tinstanceName,\n\t\t\tstate: undefined,\n\t\t\tstorage: new Map(),\n\t\t};\n\n\t\t// TODO: cache init actor in memory\n\t\t// Run actor function\n\t\tconst actor = this.constructActor(actorEntry, true);\n\t\tconst context = this.createActorContext(\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tappendTraceEntry(trace, { actorInitialize: { module: moduleName, actor: actorName } }),\n\t\t);\n\t\tlet initRes = actor.initialize(context, input);\n\t\tif (initRes instanceof Promise) initRes = await initRes;\n\n\t\t// Save state\n\t\tactorEntry.state = JSON.stringify(initRes);\n\n\t\t// Save actor\n\t\tthis.actorRegistry.set(id, actorEntry);\n\t}\n\n\tasync callActor({ moduleName, actorName, instanceName, fn, request, trace }: CallOpts): Promise<unknown> {\n\t\tconst entry = await this.getEntry(moduleName, actorName, instanceName);\n\t\tconst actor = this.constructActor(entry, false);\n\t\tactor.state = entry.state ? JSON.parse(entry.state!) : undefined;\n\n\t\tconst context = this.createActorContext(\n\t\t\tmoduleName,\n\t\t\tactorName,\n\t\t\tappendTraceEntry(trace, { actorCall: { module: moduleName, actor: actorName, fn } }),\n\t\t);\n\n\t\t// Run actor function\n\t\tlet callRes = (actor as any)[fn](context, request);\n\t\tif (callRes instanceof Promise) callRes = await callRes;\n\n\t\t// Save state\n\t\tentry.state = JSON.stringify(actor.state);\n\n\t\treturn callRes;\n\t}\n\n\tasync getOrCreateAndCallActor(\n\t\t{ moduleName, actorName, instanceName, input, fn, request, trace }: GetOrCreateAndCallOpts,\n\t): Promise<unknown> {\n\t\t// Create actor if needed\n\t\tif (!this.actorRegistry.has(await this.getId(moduleName, actorName, instanceName))) {\n\t\t\tawait this.createActor({ moduleName, actorName, instanceName, input, trace });\n\t\t}\n\n\t\t// Call actor\n\t\tconst callRes = await this.callActor({ moduleName, actorName, instanceName, fn, request, trace });\n\n\t\treturn callRes;\n\t}\n\n\tasync actorExists({ moduleName, actorName, instanceName }: ExistsOpts): Promise<boolean> {\n\t\treturn this.actorRegistry.has(await this.getId(moduleName, actorName, instanceName));\n\t}\n\n\tprivate async getId(moduleName: string, actorName: string, instanceName: string) {\n\t\tconst module = this.config.modules[moduleName];\n\t\tconst actor = module.actors[actorName];\n\t\tconst name = `%%${module.storageAlias}%%${actor.storageAlias}%%${instanceName}`;\n\t\treturn await this.hash(name);\n\t}\n\n\tprivate async getEntry(moduleName: string, actorName: string, instanceName: string): Promise<ActorEntry> {\n\t\tconst entry = this.actorRegistry.get(await this.getId(moduleName, actorName, instanceName));\n\t\tif (!entry) throw new Error(\"Actor not created\");\n\t\treturn entry;\n\t}\n\n\t/**\n\t * Creates a new instance of actor.\n\t *\n\t * `init` is true if calling `initialize` and `state` is undefined.\n\t */\n\tprivate constructActor(entry: ActorEntry, init: boolean) {\n\t\t// Create actor instance\n\t\tif (!init && entry.state === undefined) throw Error(\"actor state not initiated\");\n\n\t\t// Get actor config\n\t\tif (!(entry.moduleName in this.config.modules)) throw new Error(\"module not found\");\n\t\tconst moduleConfig = this.config.modules[entry.moduleName];\n\t\tif (!(entry.actorName in moduleConfig.actors)) throw new Error(\"actor not found\");\n\t\tconst actorConfig = moduleConfig.actors[entry.actorName];\n\n\t\t// TODO: cache actor instance in memory\n\t\t// Run actor function\n\t\tconst actor = new (actorConfig.actor)(\n\t\t\tnew MemoryStorage(entry),\n\t\t\tnew MemorySchedule(this, entry),\n\t\t);\n\n\t\treturn actor;\n\t}\n\n\tprivate createActorContext(moduleName: string, actorName: string, trace: Trace): ActorContext<ModuleContextParams> {\n\t\t// Build context\n\t\tconst module = this.config.modules[moduleName];\n\t\tconst context = new ActorContext<ModuleContextParams>(\n\t\t\tthis.runtime,\n\t\t\ttrace,\n\t\t\tmoduleName,\n\t\t\tthis.runtime.postgres.getOrCreatePrismaClient(this.runtime.config, module),\n\t\t\tmodule.db?.schema,\n\t\t\tactorName,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\n\t\treturn context;\n\t}\n\n\tprivate async hash(input: string) {\n\t\tconst data = this.encoder.encode(input);\n\t\tconst hash = await crypto.subtle.digest(\"SHA-256\", data);\n\t\tconst hashString = Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n\n\t\treturn hashString;\n\t}\n}\n\nexport { MemoryActorDriver as ActorDriver };\n",
"src/runtime/actor/drivers/memory/schedule.ts":"import { newTrace } from \"../../../mod.ts\";\nimport { ScheduleDriver } from \"../../driver.ts\";\nimport { ActorEntry, MemoryActorDriver } from \"./driver.ts\";\n\nexport class MemorySchedule implements ScheduleDriver {\n\tconstructor(private readonly driver: MemoryActorDriver, private readonly actorEntry: ActorEntry) {}\n\n\tafter(duration: number, fn: string, request: unknown): void {\n\t\tsetTimeout(() => {\n\t\t\tthis.driver.callActor({\n\t\t\t\tmoduleName: this.actorEntry.moduleName,\n\t\t\t\tactorName: this.actorEntry.actorName,\n\t\t\t\tinstanceName: this.actorEntry.instanceName,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t\ttrace: newTrace({ actorSchedule: {} }),\n\t\t\t});\n\t\t}, duration);\n\t}\n\n\tat(timestamp: number, fn: string, request: unknown): void {\n\t\tsetTimeout(() => {\n\t\t\tthis.driver.callActor({\n\t\t\t\tmoduleName: this.actorEntry.moduleName,\n\t\t\t\tactorName: this.actorEntry.actorName,\n\t\t\t\tinstanceName: this.actorEntry.instanceName,\n\t\t\t\tfn,\n\t\t\t\trequest,\n\t\t\t\ttrace: newTrace({ actorSchedule: {} }),\n\t\t\t});\n\t\t}, timestamp - Date.now());\n\t}\n}\n",
"src/runtime/actor/drivers/memory/storage.ts":"import { StorageDriver } from \"../../driver.ts\";\nimport { ActorEntry } from \"./driver.ts\";\n\nexport class MemoryStorage implements StorageDriver {\n\tconstructor(private readonly actorEntry: ActorEntry) {}\n\n\tasync get<V>(key: string): Promise<V | undefined> {\n\t\tconst value = this.actorEntry.storage.get(key);\n\t\tif (value) return JSON.parse(value);\n\t\telse return undefined;\n\t}\n\n\tasync put<V>(key: string, value: V): Promise<void> {\n\t\tthis.actorEntry.storage.set(key, JSON.stringify(value));\n\t}\n\n\tasync delete(key: string): Promise<void> {\n\t\tthis.actorEntry.storage.delete(key);\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}\n",
"src/runtime/actor/proxy.ts":"import { Trace } from \"../mod.ts\";\nimport { ActorDriver } from \"./driver.ts\";\n\n// Returned from ctx.actors.xxx\nexport class ActorProxy {\n\tconstructor(\n\t\tprivate driver: ActorDriver,\n\t\tprivate moduleName: string,\n\t\tprivate actorName: string,\n\t\tprivate trace: Trace,\n\t) {}\n\n\tasync create<Input>(instanceName: string, input: Input): Promise<void> {\n\t\tawait this.driver.createActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tinput,\n\t\t\ttrace: this.trace,\n\t\t});\n\t}\n\n\tasync call<Request, Response>(instanceName: string, fn: string, request: Request): Promise<Response> {\n\t\treturn await this.driver.callActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tfn,\n\t\t\trequest,\n\t\t\ttrace: this.trace,\n\t\t}) as Response;\n\t}\n\n\tasync getOrCreateAndCall<Input, Request, Response>(\n\t\tinstanceName: string,\n\t\tinput: Input,\n\t\tfn: string,\n\t\trequest: Request,\n\t): Promise<Response> {\n\t\treturn await this.driver.getOrCreateAndCallActor({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t\tinput,\n\t\t\tfn,\n\t\t\trequest,\n\t\t\ttrace: this.trace,\n\t\t}) as Response;\n\t}\n\n\tasync exists(instanceName: string) {\n\t\treturn await this.driver.actorExists({\n\t\t\tmoduleName: this.moduleName,\n\t\t\tactorName: this.actorName,\n\t\t\tinstanceName,\n\t\t});\n\t}\n}\n",
"src/runtime/context.ts":"import { Runtime } from \"./runtime.ts\";\nimport { stringifyTraceEntryType, Trace } from \"./trace.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { appendTraceEntry } from \"./trace.ts\";\nimport { buildActorRegistryProxy, buildDependencyRegistryProxy, RegistryCallMap } from \"./proxy.ts\";\nimport { DependencyScriptCallFunction } from \"../types/registry.ts\";\nimport { camelify } from \"../types/case_conversions.ts\";\nimport { errorToLogEntries, log, LogEntry, spreadObjectToLogEntries } from \"./logger.ts\";\nimport { LogLevel } from \"./logger.ts\";\n\nexport interface ContextParams {\n\tdependenciesSnake: any;\n\tdependenciesCamel: any;\n}\n\nexport class Context<Params extends ContextParams> {\n\tpublic readonly log: ContextLog<Params>;\n\n\tpublic constructor(\n\t\tprotected readonly runtime: Runtime<Params>,\n\t\tpublic readonly trace: Trace,\n\t\tprivate readonly dependencyCaseConversionMap: RegistryCallMap,\n\t\tprotected readonly actorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.log = new ContextLog(this);\n\t}\n\n\tprotected isAllowedModuleName(_moduleName: string): boolean {\n\t\treturn true;\n\t}\n\n\tpublic call: DependencyScriptCallFunction<this, Params[\"dependenciesSnake\"]> = async function (\n\t\tmoduleName,\n\t\tscriptName,\n\t\treq,\n\t) {\n\t\ttry {\n\t\t\t// Check if calling module is allowed to call target module\n\t\t\tif (!this.isAllowedModuleName(moduleName)) {\n\t\t\t\tthrow new RuntimeError(\n\t\t\t\t\t\"CANNOT_ACCESS_MODULE\",\n\t\t\t\t\t{ cause: `Module \\`${moduleName}\\` is not a dependency` },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Lookup module\n\t\t\tconst module = this.runtime.config.modules[moduleName];\n\t\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\t\t// Lookup script\n\t\t\tconst script = module.scripts[scriptName];\n\t\t\tif (!script) throw new Error(`Script not found: ${scriptName}`);\n\n\t\t\t// Build context\n\t\t\tconst ctx = new ScriptContext(\n\t\t\t\tthis.runtime,\n\t\t\t\tappendTraceEntry(this.trace, {\n\t\t\t\t\tscript: { module: moduleName, script: scriptName },\n\t\t\t\t}),\n\t\t\t\tmoduleName,\n\t\t\t\tthis.runtime.postgres.getOrCreatePrismaClient(this.runtime.config, module),\n\t\t\t\tmodule.db?.schema,\n\t\t\t\tscriptName,\n\t\t\t\tthis.dependencyCaseConversionMap,\n\t\t\t\tthis.actorCaseConversionMap,\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Compile schemas\n\t\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t\t// const validateResponse = this.runtime.ajv.compile(script.responseSchema);\n\n\t\t\t// // Validate request\n\t\t\t// if (!validateRequest(req)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid request: ${JSON.stringify(validateRequest.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\t// Log start\n\t\t\tconst scriptStart = performance.now();\n\t\t\tctx.log.debug(\"script request\", ...spreadObjectToLogEntries(\"request\", req));\n\n\t\t\t// Execute script\n\t\t\tconst duration = Math.ceil(performance.now() - scriptStart);\n\t\t\tconst res = await ctx.runBlock(async () => await script.run(ctx, req));\n\n\t\t\t// Log finish\n\t\t\t//\n\t\t\t// `duration` will be 0 on Cloudflare Workers if there are no async\n\t\t\t// actions performed inside of the request:\n\t\t\t// https://developers.cloudflare.com/workers/runtime-apis/performance/\n\t\t\tctx.log.debug(\n\t\t\t\t\"script response\",\n\t\t\t\t...(duration > 0 ? [[\"duration\", `${duration}ms`] as LogEntry] : []),\n\t\t\t\t...spreadObjectToLogEntries(\"response\", res),\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Validate response\n\t\t\t// if (!validateResponse(res)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid response: ${JSON.stringify(validateResponse.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\treturn res as any;\n\t\t} catch (error) {\n\t\t\tthis.log.warn(\n\t\t\t\t\"script error\",\n\t\t\t\t...errorToLogEntries(\"error\", error),\n\t\t\t);\n\t\t\tthrow error;\n\t\t}\n\t};\n\n\tpublic get modules() {\n\t\treturn buildDependencyRegistryProxy<Params>(\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tpublic async tryCallRaw(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\treq: unknown,\n\t): Promise<object | null> {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return null;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return null;\n\n\t\treturn await this.call(moduleName as any, scriptName as any, req as any);\n\t}\n\n\tpublic canCall(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\t_req?: unknown,\n\t): boolean {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return false;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return false;\n\n\t\t// TODO: Replace with OGBE-15\n\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t// if (req && !validateRequest(req)) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Runs a block of code and catches any related errors.\n\t */\n\tpublic async runBlock<Res>(fn: () => Promise<Res>) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (cause) {\n\t\t\tif (cause instanceof RuntimeError) {\n\t\t\t\t// Enrich error with more context\n\t\t\t\tcause.enrich(this.runtime, this);\n\t\t\t\tthrow cause;\n\t\t\t} else {\n\t\t\t\t// Convert to RuntimeError\n\t\t\t\tconst error = new RuntimeError(\"INTERNAL_ERROR\", { cause });\n\t\t\t\terror.enrich(this.runtime, this);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass ContextLog<Params extends ContextParams> {\n\tconstructor(private readonly context: Context<Params>) {}\n\n\tprivate log(level: LogLevel, message: string, ...data: LogEntry[]) {\n\t\tconst trace = this.context.trace.entries.map((x) => stringifyTraceEntryType(x.type)).join(\" > \");\n\n\t\tlog(\n\t\t\tlevel,\n\t\t\tmessage,\n\t\t\t[\"trace\", trace],\n\t\t\t...data,\n\t\t);\n\t}\n\n\tpublic error(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"error\", message, ...data);\n\t}\n\n\tpublic warn(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"warn\", message, ...data);\n\t}\n\n\tpublic info(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"info\", message, ...data);\n\t}\n\n\tpublic debug(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"debug\", message, ...data);\n\t}\n\n\tpublic trace(message: string, ...data: LogEntry[]) {\n\t\tthis.log(\"trace\", message, ...data);\n\t}\n}\n\nexport interface ModuleContextParams extends ContextParams {\n\tactorsSnake: any;\n\tactorsCamel: any;\n\tuserConfig: any;\n\tdatabase: any;\n\tdatabaseSchema: any;\n}\n\n/**\n * Context for a module.\n */\nexport class ModuleContext<Params extends ModuleContextParams> extends Context<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tpublic readonly moduleName: string,\n\t\tpublic readonly db: Params[\"database\"],\n\t\tpublic readonly dbSchema: Params[\"databaseSchema\"],\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n\n\tprotected isAllowedModuleName(targetModuleName: string): boolean {\n\t\treturn this.runtime.config\n\t\t\t.modules[this.moduleName]\n\t\t\t?.dependencies\n\t\t\t.has(targetModuleName);\n\t}\n\n\tpublic get config(): Params[\"userConfig\"] {\n\t\treturn this.runtime.config.modules[this.moduleName].userConfig as Params[\"userConfig\"];\n\t}\n\n\tpublic get actors() {\n\t\treturn buildActorRegistryProxy<Params[\"actorsSnake\"], Params[\"actorsCamel\"]>(\n\t\t\tthis.runtime,\n\t\t\t// TODO: Find a better way of looking up the module name. We don't use\n\t\t\t// camel -> snake conversions anymore for modules in actors.\n\t\t\tthis.actorCaseConversionMap[camelify(this.moduleName)],\n\t\t\tthis.trace,\n\t\t);\n\t}\n}\n\n/**\n * Context for a script.\n */\nexport class ScriptContext<Params extends ModuleContextParams> extends ModuleContext<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: Params[\"database\"],\n\t\tdbSchema: Params[\"databaseSchema\"],\n\t\tpublic readonly scriptName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dbSchema, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n}\n\n/**\n * Context for an actor.\n */\nexport class ActorContext<Params extends ModuleContextParams> extends ModuleContext<Params> {\n\tpublic constructor(\n\t\truntime: Runtime<Params>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: Params[\"database\"],\n\t\tdbSchema: Params[\"databaseSchema\"],\n\t\tpublic readonly actorName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dbSchema, dependencyCaseConversionMap, actorCaseConversionMap);\n\t}\n}\n\n/**\n * Context for a test.\n */\nexport class TestContext<Params extends ModuleContextParams> extends ModuleContext<Params> {}\n",
"src/runtime/deps.ts":"import * as Ajv from \"https://esm.sh/ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"https://esm.sh/ajv-formats@^2.1.1\";\nexport { addFormats };\n",
"src/runtime/error.ts":"import { ModuleContext } from \"./context.ts\";\nimport { Context } from \"./context.ts\";\nimport { ModuleContextParams } from \"./mod.ts\";\nimport { ErrorConfig, Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\n\nexport interface RuntimeErrorOptions extends ErrorOptions {\n\tmeta?: any;\n}\n\nexport class RuntimeError extends Error {\n\t/**\n\t * The module this error originated from.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic moduleName?: string;\n\n\t/**\n\t * Call trace of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic trace?: Trace;\n\n\t/**\n\t * Config of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic errorConfig?: ErrorConfig;\n\n\t/**\n\t * Additional metadata of the error.\n\t */\n\tpublic meta?: ErrorConfig;\n\n\tpublic constructor(\n\t\tpublic readonly code: string,\n\t\toptions?: RuntimeErrorOptions,\n\t) {\n\t\tsuper(code, options);\n\t\tthis.meta = options?.meta;\n\t}\n\n\t/**\n\t * Called by `Context` when an error is caught.\n\t */\n\tpublic enrich<\n\t\tParams extends ModuleContextParams,\n\t\tCtx extends Context<Params>,\n\t>(\n\t\truntime: Runtime<Params>,\n\t\tcontext: Ctx,\n\t) {\n\t\t// Add context to error\n\t\tif (context instanceof ModuleContext) {\n\t\t\tthis.moduleName = context.moduleName;\n\t\t}\n\t\tthis.trace = context.trace;\n\n\t\t// Lookup error config if doesn't already exist\n\t\tif (!this.errorConfig && this.moduleName) {\n\t\t\tconst errorConfig = runtime.config.modules[this.moduleName]?.errors[this.code];\n\t\t\tif (errorConfig) {\n\t\t\t\tthis.errorConfig = errorConfig;\n\t\t\t\tif (errorConfig.description) {\n\t\t\t\t\tthis.message = `${this.moduleName}[${this.code}]: ${errorConfig.description}`;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontext.log.warn(\n\t\t\t\t\t\"error config not found. if you are the module author, check the error exists in module.json.\",\n\t\t\t\t\t[\"errorCode\", this.code],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Build enriched message\n\t\tlet message = \"\";\n\t\tif (this.moduleName) {\n\t\t\tmessage += `${this.moduleName}[${this.code}]`;\n\t\t} else {\n\t\t\tmessage += this.code;\n\t\t}\n\t\tif (this.errorConfig?.description) {\n\t\t\tmessage += `: ${this.errorConfig.description}`;\n\t\t}\n\t\tthis.message = message;\n\t}\n}\n\nexport class UnreachableError extends RuntimeError {\n\tconstructor(public readonly value: never) {\n\t\tsuper(\"internal_error\", { meta: { value } });\n\t}\n}\n",
"src/runtime/error_test.ts":"import { unimplemented } from \"https://deno.land/std@0.208.0/assert/unimplemented.ts\";\nimport { assertEquals, assertExists } from \"../deps.ts\";\nimport { ModuleContext } from \"./context.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { BuildRuntime, ModuleContextParams, newTrace } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\nimport { ActorDriver, CallOpts, CreateOpts, ExistsOpts, GetOrCreateAndCallOpts } from \"./actor/driver.ts\";\n\ninterface Params extends ModuleContextParams {\n\tdependenciesSnake: { test_module: Record<string, never> };\n\tdependenciesCamel: { testModule: Record<string, never> };\n\tactorsSnake: Record<never, never>;\n\tactorsCamel: Record<never, never>;\n\tuserConfig: null;\n\tdatabase: undefined;\n\tdatabaseSchema: undefined;\n}\n\nclass DummyActorDriver implements ActorDriver {\n\tcreateActor(_opts: CreateOpts): Promise<void> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tcallActor(_opts: CallOpts): Promise<unknown> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tgetOrCreateAndCallActor(_opts: GetOrCreateAndCallOpts): Promise<unknown> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n\tactorExists(_opts: ExistsOpts): Promise<boolean> {\n\t\tthrow new Error(\"Method not implemented.\");\n\t}\n}\n\nDeno.test(\"error\", async () => {\n\tconst dependencyCaseConversionMap = {\n\t\ttestModule: {},\n\t} as const;\n\tconst actorCaseConversionMap = {} as const;\n\n\t// Setup\n\tconst runtime = new Runtime<Params>(\n\t\t{\n\t\t\truntime: BuildRuntime.Deno,\n\t\t\tmodules: {\n\t\t\t\ttest_module: {\n\t\t\t\t\tstorageAlias: \"test_module\",\n\t\t\t\t\tscripts: {},\n\t\t\t\t\tactors: {},\n\t\t\t\t\terrors: {\n\t\t\t\t\t\t\"TEST_ERROR\": {},\n\t\t\t\t\t},\n\t\t\t\t\tdependencies: new Set([\"test_module\"]),\n\t\t\t\t\tuserConfig: null,\n\t\t\t\t},\n\t\t\t},\n\t\t\tdb: {\n\t\t\t\tcreatePgPool: () => unimplemented(),\n\t\t\t},\n\t\t},\n\t\tnew DummyActorDriver(),\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\tconst moduleContext = new ModuleContext<Params>(\n\t\truntime,\n\t\tnewTrace({ internalTest: {} }),\n\t\t\"test_module\",\n\t\tundefined,\n\t\tundefined,\n\t\tdependencyCaseConversionMap,\n\t\tactorCaseConversionMap,\n\t);\n\n\t// Create error\n\tconst error = new RuntimeError(\"TEST_ERROR\");\n\tassertEquals(error.message.split(\"\\n\")[0], \"TEST_ERROR\");\n\n\t// Erich error\n\terror.enrich(runtime, moduleContext);\n\tassertExists(error.moduleName);\n\tassertExists(error.trace);\n\tassertExists(error.errorConfig);\n\tassertEquals(error.message.split(\"\\n\")[0], \"test_module[TEST_ERROR]\");\n});\n",
"src/runtime/logger.ts":"import { RuntimeError } from \"./error.ts\";\n\nexport type LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n\nexport type LogEntry = [string, LogValue];\nexport type LogValue = string | number | boolean | null | undefined;\n\nconst LOG_LEVEL_COLORS: Record<LogLevel, string> = {\n\terror: \"\\x1b[31m\", // Red\n\twarn: \"\\x1b[33m\", // Yellow\n\tinfo: \"\\x1b[32m\", // Green\n\tdebug: \"\\x1b[36m\", // Cyan\n\ttrace: \"\\x1b[35m\", // Magenta\n};\n\nconst RESET_COLOR = \"\\x1b[0m\";\n\nfunction isColorEnabled(): boolean {\n\tif (Deno.env.get(\"OPENGB_TERM_COLOR\") === \"never\") return false;\n\tif (Deno.env.get(\"OPENGB_TERM_COLOR\") === \"always\") return true;\n\treturn Deno.stdout.isTerminal();\n}\n\nexport function log(level: LogLevel, message: string, ...data: LogEntry[]) {\n\tlogRaw(\n\t\tlevel,\n\t\t[\"ts\", getFormattedTimestamp()],\n\t\t[\"level\", level],\n\t\t[\"msg\", message],\n\t\t...data,\n\t);\n}\n\nexport function logRaw(level: LogLevel, ...data: any[]) {\n\tconst colorEnabled = isColorEnabled();\n\n\tlet message = stringify(...data);\n\n\tif (colorEnabled) {\n\t\tmessage = `${LOG_LEVEL_COLORS[level]}${message}${RESET_COLOR}`;\n\t}\n\n\toriginalConsole.log(message);\n}\n\n/**\n * Serializes logfmt line using orderer parameters.\n *\n * We use varargs because it's ordered & it has less overhead than an object.\n *\n * ## Styling Methodology\n *\n * The three things you need to know for every log line is the level, the\n * message, and who called it. These properties are highlighted in different colros\n * and sorted in th eorder that you usually read them.\n *\n * Once you've found a log line you care about, then you want to find the\n * property you need to see. The property names are bolded and the default color\n * while the rest of the data is dim. This lets you scan to find the property\n * name quickly then look closer to read the data associated with the\n * property.\n */\nexport function stringify(...data: LogEntry[]) {\n\tlet line = \"\";\n\n\tfor (let i = 0; i < data.length; i++) {\n\t\tconst [key, valueRaw] = data[i];\n\n\t\tlet isNull = false;\n\t\tlet valueString: string;\n\t\tif (valueRaw == null) {\n\t\t\tisNull = true;\n\t\t\tvalueString = \"\";\n\t\t} else {\n\t\t\tvalueString = valueRaw.toString();\n\t\t}\n\n\t\tconst needsQuoting = valueString.indexOf(\" \") > -1 || valueString.indexOf(\"=\") > -1;\n\t\tconst needsEscaping = valueString.indexOf('\"') > -1 || valueString.indexOf(\"\\\\\") > -1;\n\n\t\tif (needsEscaping) valueString = valueString.replace(/[\"\\\\]/g, \"\\\\$&\");\n\t\tif (needsQuoting || needsEscaping) valueString = '\"' + valueString + '\"';\n\t\tif (valueString === \"\" && !isNull) valueString = '\"\"';\n\n\t\tif (isColorEnabled()) {\n\t\t\t// With color\n\n\t\t\t// Secial message colors\n\t\t\tlet color = \"\\x1b[2m\";\n\t\t\tif (key == \"level\" && valueString in LOG_LEVEL_COLORS) {\n\t\t\t\tcolor = LOG_LEVEL_COLORS[valueString as LogLevel];\n\t\t\t} else if (key == \"msg\") {\n\t\t\t\tcolor = \"\\x1b[32m\";\n\t\t\t} else if (key == \"trace\") {\n\t\t\t\tcolor = \"\\x1b[34m\";\n\t\t\t}\n\n\t\t\t// Format line\n\t\t\tline += \"\\x1b[0m\\x1b[1m\" + key + \"\\x1b[0m\" + \"\\x1b[2m=\\x1b[0m\" + color + valueString + RESET_COLOR;\n\t\t} else {\n\t\t\t// No color\n\t\t\tline += key + \"=\" + valueString;\n\t\t}\n\n\t\tif (i != data.length - 1) {\n\t\t\tline += \" \";\n\t\t}\n\t}\n\n\treturn line;\n}\n\nexport function getFormattedTimestamp() {\n\tconst now = new Date();\n\n\tconst year = now.getUTCFullYear();\n\tconst month = String(now.getUTCMonth() + 1).padStart(2, \"0\");\n\tconst day = String(now.getUTCDate()).padStart(2, \"0\");\n\tconst hours = String(now.getUTCHours()).padStart(2, \"0\");\n\tconst minutes = String(now.getUTCMinutes()).padStart(2, \"0\");\n\tconst seconds = String(now.getUTCSeconds()).padStart(2, \"0\");\n\tconst milliseconds = String(now.getUTCMilliseconds()).padStart(3, \"0\");\n\n\treturn `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${milliseconds}Z`;\n}\n\nfunction castToLogValue(v: unknown): LogValue {\n\tif (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\" || v === null || v === undefined) {\n\t\treturn v;\n\t}\n\treturn JSON.stringify(v);\n}\n\n// Patch console methods\nconst originalConsole = { ...console };\n\nfunction consoleLogWrapper(level: LogLevel, ...args: unknown[]) {\n\tconst data: LogEntry[] = args.slice(1).map((v, i) => [`data${i}`, castToLogValue(v)]);\n\tlog(level, args[0] as string, ...data);\n}\n\nconsole.error = consoleLogWrapper.bind(undefined, \"error\");\nconsole.warn = consoleLogWrapper.bind(undefined, \"warn\");\nconsole.info = consoleLogWrapper.bind(undefined, \"info\");\nconsole.log = consoleLogWrapper.bind(undefined, \"info\");\nconsole.debug = consoleLogWrapper.bind(undefined, \"debug\");\nconsole.trace = consoleLogWrapper.bind(undefined, \"trace\");\n\n// MARK: Utils\nconst SPREAD_OBJECT = Deno.env.get(\"_OPENGB_LOG_SPILT_OBJECT\") == \"1\";\n/**\n * Converts an object in to an easier to read KV of entries.\n */\nexport function spreadObjectToLogEntries(base: string, data: unknown): LogEntry[] {\n\tif (\n\t\tSPREAD_OBJECT && typeof data == \"object\" && !Array.isArray(data) && data !== null &&\n\t\tObject.keys(data).length != 0 && Object.keys(data).length < 16\n\t) {\n\t\tconst logData: LogEntry[] = [];\n\t\tfor (let key in data) {\n\t\t\t// logData.push([`${base}.${key}`, JSON.stringify((data as any)[key])]);\n\t\t\tlogData.push(...spreadObjectToLogEntries(`${base}.${key}`, (data as any)[key]));\n\t\t}\n\t\treturn logData;\n\t} else {\n\t\treturn [[base, JSON.stringify(data)]];\n\t}\n}\n\nexport function errorToLogEntries(base: string, error: Error): LogEntry[] {\n\tif (error instanceof RuntimeError) {\n\t\treturn [\n\t\t\t[`${base}.code`, error.code],\n\t\t\t[`${base}.description`, error.errorConfig?.description],\n\t\t\t[`${base}.module`, error.moduleName],\n\t\t\t...(error.meta ? [[`${base}.meta`, JSON.stringify(error.meta)] as LogEntry] : []),\n\t\t\t...(error.cause instanceof Error ? errorToLogEntries(`${base}.cause`, error.cause) : []),\n\t\t];\n\t} else {\n\t\treturn [\n\t\t\t[`${base}.name`, error.name],\n\t\t\t[`${base}.message`, error.message],\n\t\t\t...(error.cause instanceof Error ? errorToLogEntries(`${base}.cause`, error.cause) : []),\n\t\t];\n\t}\n}\n",
"src/runtime/mod.ts":"export * from \"./context.ts\";\nexport * from \"./error.ts\";\nexport * from \"./runtime.ts\";\nexport * from \"./trace.ts\";\n\n// This will shim console.log\nimport \"./logger.ts\";\n",
"src/runtime/postgres.ts":"import { Module } from \"./runtime.ts\";\nimport { Config } from \"./mod.ts\";\nimport { getDatabaseUrl } from \"../utils/db.ts\";\n\n/**\n * Unknown driver type.\n */\nexport interface PgPoolDummy {\n\tend?: () => Promise<void>;\n}\n\n/**\n * We don't have access to the generated Prisma type, so we create an interface with only what we need to interact with.\n *\n * This will be converted to the full Prisma type when passed to the context.\n */\nexport interface PrismaClientDummy {\n\t$disconnect(): Promise<void>;\n}\n\n/** Manages Postgres connections. */\nexport class Postgres {\n\tprivate isShutDown = false;\n\n\tprivate pgPool?: PgPoolDummy;\n\tpublic prismaClients = new Map<string, PrismaClientDummy>();\n\n\tpublic async shutdown() {\n\t\tthis.isShutDown = true;\n\t\tfor (const client of this.prismaClients.values()) {\n\t\t\tawait client.$disconnect();\n\t\t}\n\t\tif (this.pgPool?.end) await this.pgPool.end();\n\t}\n\n\tpublic getOrCreatePgPool(config: Config): PgPoolDummy {\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.pgPool) {\n\t\t\treturn this.pgPool;\n\t\t} else {\n\t\t\tconst url = getDatabaseUrl();\n\n\t\t\t// Create & insert pool\n\t\t\tconst output = config.db.createPgPool(url);\n\t\t\tthis.pgPool = output;\n\t\t\treturn output;\n\t\t}\n\t}\n\n\tpublic getOrCreatePrismaClient(config: Config, module: Module): PrismaClientDummy | undefined {\n\t\tif (!module.db) return undefined;\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.prismaClients.has(module.db.schema)) {\n\t\t\treturn this.prismaClients.get(module.db.schema)!;\n\t\t} else {\n\t\t\t// Create & insert pool\n\t\t\tconst pool = this.getOrCreatePgPool(config);\n\t\t\tconst client = module.db.createPrismaClient(pool, module.db.schema);\n\t\t\tthis.prismaClients.set(module.db.schema, client);\n\t\t\treturn client;\n\t\t}\n\t}\n}\n\n/** Dummy type to represent places where we reference a specific database. */\nexport type PostgresWrapped<T> = T;\n",
"src/runtime/proxy.ts":"import { Context, Runtime, Trace } from \"../runtime/mod.ts\";\nimport { RequestOf, ResponseOf } from \"../types/registry.ts\";\nimport { ActorProxy } from \"./actor/proxy.ts\";\nimport { ContextParams } from \"./context.ts\";\n\ntype ModuleRegistryPair = readonly [string, string];\n\n/**\n * This type is used denote a map the key/value pairs of one registry to\n * another.\n *\n * Example:\n * ```ts\n * type TestReg1 = {\n *   foo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     baz: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   fil: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   }\n * };\n *\n * type TestReg2 = {\n *   canonicalFoo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     bazScript: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   filMod: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   },\n * };\n *\n * const map: RegistryCallMap<TestReg1, TestReg2> = {\n *   foo: {\n *     bar: [\"canonicalFoo\", \"bar\"],\n *     baz: [\"canonicalFoo\", \"bazScript\"],\n *   },\n *   fil: {\n *     qux: [\"filMod\", \"qux\"],\n *     cor: [\"filMod\", \"cor\"],\n *   },\n * };\n * ```\n *\n * This is used by the {@linkcode buildDependencyRegistryProxy} function to map the camel\n * case keys from `ctx.modules.<camelMod>.<camelScript>(data);` to an\n * equivalent call to `ctx.call(<snake_mod>, <snake_script>, data);`.\n */\nexport type RegistryCallMap = Record<string, ModuleCallMap>;\n\nexport type ModuleCallMap = Record<string, ModuleRegistryPair>;\n\n/**\n * A callable registry is an object that describes the structure of\n * `ctx.modules`.\n *\n * If we have a registry like this:\n * - module `foo`\n *   - script `bar`\n *     - request type `BarRequest`\n *     - response type `BarResponse`\n *   - script `baz`\n *     - request type `BazRequest`\n *     - response type `BazResponse`\n * - module `fil`\n *   - script `qux`\n *     - request type `QuxRequest`\n *     - response type `QuxResponse`\n *   - script `cor`\n *     - request type `CorRequest`\n *     - response type `CorResponse`\n *\n * The callable registry would look like this:\n * ```ts\n * type CallableRegistry_TestReg = {\n *   foo: {\n *     bar: (req: BarRequest) => Promise<BarResponse>,\n *     baz: (req: BazRequest) => Promise<BazResponse>,\n *   },\n *   fil: {\n *     qux: (req: QuxRequest) => Promise<QuxResponse>,\n *     cor: (req: CorRequest) => Promise<CorResponse>,\n *   },\n * }\n * ```\n *\n * This is the type returned by the {@linkcode buildDependencyRegistryProxy} function.\n *\n * It is accessible to the user as `ctx.modules`.\n */\nexport type CallableDependencies<DependenciesT> = {\n\t[Mod in keyof DependenciesT]: {\n\t\t[Script in keyof DependenciesT[Mod]]: (\n\t\t\treq: RequestOf<DependenciesT[Mod][Script]>,\n\t\t) => Promise<ResponseOf<DependenciesT[Mod][Script]>>;\n\t};\n};\n\n/**\n * TODO: Comment\n */\nexport type ActorProxies<ActorsT> = {\n\t[Actor in keyof ActorsT]: ActorProxy;\n};\n\n/**\n * @param ctx The {@link Context} object to use to call the scripts in\n * accessible modules\n * @param map A {@link MapFrom} object that describes how to map\n * `[module, script] pairs from a camelCase registry to a snake_case registry\n * @returns A {@link CallableDependencies} object that implements the \"syntax sugar\"\n * that used in the `ctx.modules.<script>.<name>()` pattern to call scripts\n * without the `ctx.call` function.\n */\nexport function buildDependencyRegistryProxy<Params extends ContextParams>(\n\tctx: Context<Params>,\n\tdependenciesMapCamelToSnake: RegistryCallMap,\n): CallableDependencies<Params[\"dependenciesCamel\"]> {\n\tconst handler = {\n\t\tget: (_target: unknown, camelCaseModuleKey: string) => {\n\t\t\tif (camelCaseModuleKey in dependenciesMapCamelToSnake) {\n\t\t\t\tconst camelToSnakeMapForModule = dependenciesMapCamelToSnake[camelCaseModuleKey];\n\n\t\t\t\treturn new Proxy(camelToSnakeMapForModule, {\n\t\t\t\t\tget: (_target: unknown, scriptProp: string) => {\n\t\t\t\t\t\tif (scriptProp in camelToSnakeMapForModule) {\n\t\t\t\t\t\t\tconst [snakeCaseModule, snakeCaseScript] = camelToSnakeMapForModule[scriptProp];\n\t\t\t\t\t\t\treturn (req: unknown) => {\n\t\t\t\t\t\t\t\treturn ctx.call(\n\t\t\t\t\t\t\t\t\tsnakeCaseModule as any,\n\t\t\t\t\t\t\t\t\tsnakeCaseScript as any,\n\t\t\t\t\t\t\t\t\treq as any,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t};\n\treturn new Proxy({}, handler) as CallableDependencies<Params[\"dependenciesCamel\"]>;\n}\n\nexport function buildActorRegistryProxy<ActorsSnakeT, ActorsCamelT>(\n\truntime: Runtime<any>,\n\tactorMap: ModuleCallMap,\n\ttrace: Trace,\n): ActorProxies<ActorsCamelT> {\n\treturn new Proxy(actorMap, {\n\t\tget: (_target: unknown, actorProp: string) => {\n\t\t\tif (actorProp in actorMap) {\n\t\t\t\tconst pair = actorMap[actorProp as keyof typeof actorMap];\n\t\t\t\treturn new ActorProxy(\n\t\t\t\t\truntime.actorDriver,\n\t\t\t\t\tpair[0] as any,\n\t\t\t\t\tpair[1] as any,\n\t\t\t\t\ttrace,\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t}) as ActorProxies<ActorsCamelT>;\n}\n",
"src/runtime/runtime.ts":"import { addFormats, Ajv } from \"./deps.ts\";\nimport { ModuleContextParams, ScriptContext } from \"./context.ts\";\nimport { Context, TestContext } from \"./context.ts\";\nimport { PgPoolDummy, Postgres, PrismaClientDummy } from \"./postgres.ts\";\nimport { handleRequest } from \"./server.ts\";\nimport { TraceEntryType } from \"./trace.ts\";\nimport { newTrace } from \"./trace.ts\";\nimport { RegistryCallMap } from \"./proxy.ts\";\nimport { ActorDriver } from \"./actor/driver.ts\";\nimport { ActorBase } from \"./actor/actor.ts\";\nimport { ContextParams } from \"./mod.ts\";\nimport { errorToLogEntries, log } from \"./logger.ts\";\n\nexport interface Config {\n\truntime: BuildRuntime;\n\tmodules: Record<string, Module>;\n\tcors?: CorsConfig;\n\tdb: {\n\t\tcreatePgPool: (url: URL) => PgPoolDummy;\n\t};\n}\n\n/**\n * Which runtime to target when building.\n */\nexport enum BuildRuntime {\n\tDeno,\n\tCloudflare,\n}\n\nexport interface Module {\n\tstorageAlias: string;\n\tscripts: Record<string, Script>;\n\tactors: Record<string, Actor>;\n\terrors: Record<string, ErrorConfig>;\n\tdb?: {\n\t\t/** Name of the Postgres schema the tables live in. */\n\t\tschema: string;\n\t\tcreatePrismaClient: (pool: PgPoolDummy, schema: string) => PrismaClientDummy;\n\t};\n\tdependencies: Set<string>;\n\tuserConfig: unknown;\n}\n\nexport interface CorsConfig {\n\torigins: Set<string>;\n}\n\nexport interface Script {\n\t// deno-lint-ignore no-explicit-any\n\trun: ScriptRun<any, any, any, any, any>;\n\t// deno-lint-ignore no-explicit-any\n\trequestSchema: any;\n\t// deno-lint-ignore no-explicit-any\n\tresponseSchema: any;\n\tpublic: boolean;\n}\n\nexport type ScriptRun<Req, Res, UserConfigT, DatabaseT, DatabaseSchemaT> = (\n\tctx: ScriptContext<{\n\t\tdependenciesSnake: any;\n\t\tdependenciesCamel: any;\n\t\tactorsSnake: any;\n\t\tactorsCamel: any;\n\t\tuserConfig: UserConfigT;\n\t\tdatabase: DatabaseT;\n\t\tdatabaseSchema: DatabaseSchemaT;\n\t}>,\n\treq: Req,\n) => Promise<Res>;\n\nexport interface Actor {\n\t// This monstrosity is to allow passing the constructor a subclass of ActorBase.\n\tactor: new (\n\t\t...args: ConstructorParameters<typeof ActorBase<unknown, unknown>>\n\t) => ActorBase<unknown, unknown>;\n\tstorageAlias: string;\n}\n\nexport interface ErrorConfig {\n\tdescription?: string;\n}\n\nexport class Runtime<Params extends ContextParams> {\n\tpublic postgres: Postgres;\n\n\tpublic ajv: Ajv.default;\n\n\tpublic constructor(\n\t\tpublic config: Config,\n\t\tpublic actorDriver: ActorDriver,\n\t\tprivate dependencyCaseConversionMap: RegistryCallMap,\n\t\tprivate actorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tthis.postgres = new Postgres();\n\n\t\tthis.ajv = new Ajv.default({\n\t\t\tremoveAdditional: true,\n\t\t});\n\t\t// TODO: Why are types incompatible\n\t\taddFormats.default(this.ajv as any);\n\t}\n\n\tprivate async shutdown() {\n\t\tawait this.postgres.shutdown();\n\t}\n\n\tpublic createRootContext(\n\t\ttraceEntryType: TraceEntryType,\n\t): Context<{ dependenciesSnake: Params[\"dependenciesSnake\"]; dependenciesCamel: Params[\"dependenciesCamel\"] }> {\n\t\treturn new Context(\n\t\t\tthis,\n\t\t\tnewTrace(traceEntryType, this.config.runtime),\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t\tthis.actorDependencyCaseConversionMap,\n\t\t);\n\t}\n\n\t/**\n\t * Serves the runtime as an HTTP server.\n\t */\n\tpublic async serve() {\n\t\tconst host = Deno.env.get(\"HOST\") ?? \"127.0.0.1\";\n\t\tconst port = parseInt(Deno.env.get(\"PORT\") ?? \"6420\");\n\t\tawait Deno.serve(\n\t\t\t{\n\t\t\t\tport,\n\t\t\t\tonListen() {\n\t\t\t\t\tlog(\"info\", \"server started\", [\"endpoint\", `http://${host}:${port}`]);\n\t\t\t\t},\n\t\t\t},\n\t\t\t(req, info) => handleRequest(this, req, { remoteAddress: info.remoteAddr.hostname }),\n\t\t).finished;\n\t}\n\n\t/**\n\t * Registers a module test with the Deno runtime.\n\t */\n\tpublic static test<Params extends ModuleContextParams>(\n\t\tconfig: Config,\n\t\tactorDriver: ActorDriver,\n\t\tmoduleName: string,\n\t\ttestName: string,\n\t\tfn: (\n\t\t\tctx: TestContext<Params>,\n\t\t) => Promise<void>,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t\tactorDependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tDeno.test({\n\t\t\tname: testName,\n\n\t\t\t// TODO: https://github.com/rivet-gg/opengb-engine/issues/35\n\t\t\tsanitizeOps: false,\n\t\t\tsanitizeResources: false,\n\n\t\t\tasync fn() {\n\t\t\t\tconst runtime = new Runtime<Params>(\n\t\t\t\t\tconfig,\n\t\t\t\t\tactorDriver,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Build context\n\t\t\t\tconst module = config.modules[moduleName];\n\t\t\t\tconst ctx = new TestContext<Params>(\n\t\t\t\t\truntime,\n\t\t\t\t\tnewTrace({\n\t\t\t\t\t\ttest: { module: moduleName, name: testName },\n\t\t\t\t\t}),\n\t\t\t\t\tmoduleName,\n\t\t\t\t\truntime.postgres.getOrCreatePrismaClient(runtime.config, module),\n\t\t\t\t\tmodule.db?.schema,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t\tactorDependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Run test\n\t\t\t\ttry {\n\t\t\t\t\tawait ctx.runBlock(async () => {\n\t\t\t\t\t\tawait fn(ctx);\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tlog(\n\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\"failed to execute test\",\n\t\t\t\t\t\t[\"module\", moduleName],\n\t\t\t\t\t\t[\"test\", testName],\n\t\t\t\t\t\t...errorToLogEntries(\"cause\", cause),\n\t\t\t\t\t);\n\t\t\t\t\tthrow cause;\n\t\t\t\t} finally {\n\t\t\t\t\tawait runtime.shutdown();\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Only runs on a CORS preflight request— returns a response with the\n\t * appropriate CORS headers & status.\n\t *\n\t * @param req The preflight OPTIONS request\n\t * @returns The full response to the preflight request\n\t */\n\tpublic corsPreflight(req: Request): Response {\n\t\tconst origin = req.headers.get(\"Origin\");\n\t\tif (origin) {\n\t\t\tconst normalizedOrigin = new URL(origin).origin;\n\t\t\tif (this.config.cors) {\n\t\t\t\tif (this.config.cors.origins.has(normalizedOrigin)) {\n\t\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\t\tstatus: 204,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t...this.corsHeaders(req),\n\t\t\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Origin is not allowed/no origin header on preflight\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"CORS origin not allowed. See https://opengb.dev/docs/cors\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\tstatus: 403,\n\t\t\t\theaders: {\n\t\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\t}\n\n\tpublic corsHeaders(req: Request): Record<string, string> {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\t// Don't set CORS headers if there's no origin (e.g. a server-side\n\t\t// request)\n\t\tif (!origin) return {};\n\n\t\t// If the origin is allowed, return the appropriate headers.\n\t\t// Otherwise, return a non-matching cors header (empty object).\n\t\tif (this.config.cors?.origins.has(origin)) {\n\t\t\treturn {\n\t\t\t\t\"Access-Control-Allow-Origin\": new URL(origin).origin,\n\t\t\t\t\"Access-Control-Allow-Methods\": \"*\",\n\t\t\t\t\"Access-Control-Allow-Headers\": \"*\",\n\t\t\t};\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tpublic corsAllowed(req: Request): boolean {\n\t\tconst origin = req.headers.get(\"Origin\");\n\n\t\tif (!origin) return true;\n\t\treturn this.config.cors?.origins.has(origin) ?? false;\n\t}\n}\n",
"src/runtime/server.ts":"import { RuntimeError } from \"./error.ts\";\nimport { errorToLogEntries, LogEntry } from \"./logger.ts\";\nimport { Context, ModuleContextParams } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\n\nconst MODULE_CALL = /^\\/modules\\/(?<module>\\w+)\\/scripts\\/(?<script>\\w+)\\/call\\/?$/;\n\ninterface RequestInfo {\n\tremoteAddress: string;\n}\n\nexport async function handleRequest<Params extends ModuleContextParams>(\n\truntime: Runtime<Params>,\n\treq: Request,\n\tinfo: RequestInfo,\n): Promise<Response> {\n\tconst url = new URL(req.url);\n\n\t// Create context\n\tconst ctx = runtime.createRootContext({\n\t\thttpRequest: {\n\t\t\tmethod: req.method,\n\t\t\tpath: url.pathname,\n\t\t\tremoteAddress: info.remoteAddress,\n\t\t\theaders: Object.fromEntries(req.headers.entries()),\n\t\t},\n\t});\n\n\t// Log request\n\tconst start = performance.now();\n\tctx.log.debug(\n\t\t\"http request\",\n\t\t[\"method\", req.method],\n\t\t[\"path\", url.pathname],\n\t\t[\"remoteAddress\", info.remoteAddress],\n\t\t[\"userAgent\", req.headers.get(\"user-agent\")],\n\t);\n\n\t// Execute request\n\tconst res = await handleRequestInner(runtime, req, url, ctx);\n\n\t// Log response\n\t//\n\t// `duration` will be 0 on Cloudflare Workers if there are no async actions\n\t// performed inside of the request:\n\t// https://developers.cloudflare.com/workers/runtime-apis/performance/\n\tconst duration = Math.ceil(performance.now() - start);\n\tctx.log.debug(\n\t\t\"http response\",\n\t\t[\"status\", res.status],\n\t\t...(duration > 0 ? [[\"duration\", `${duration}ms`] as LogEntry] : []),\n\t);\n\n\treturn res;\n}\n\nasync function handleRequestInner<Params extends ModuleContextParams>(\n\truntime: Runtime<Params>,\n\treq: Request,\n\turl: URL,\n\tctx: Context<Params>,\n): Promise<Response> {\n\t// Handle CORS preflight\n\tif (req.method === \"OPTIONS\") {\n\t\treturn runtime.corsPreflight(req);\n\t}\n\n\t// Disallow even simple requests if CORS is not allowed\n\tif (!runtime.corsAllowed(req)) {\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 403,\n\t\t\theaders: {\n\t\t\t\t\"Vary\": \"Origin\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\t// Only allow POST requests\n\tif (req.method !== \"POST\") {\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 405,\n\t\t\theaders: {\n\t\t\t\t\"Allow\": \"POST\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\t// Get module and script name\n\tconst matches = MODULE_CALL.exec(url.pathname);\n\tif (!matches?.groups) {\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"Route not found. Make sure the URL and method are correct.\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t\tstatus: 404,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Lookup script\n\tconst moduleName = matches.groups.module;\n\tconst scriptName = matches.groups.script;\n\tconst script = runtime.config.modules[moduleName]?.scripts[scriptName];\n\n\t// Confirm script exists and is public\n\tif (!script || !script.public) {\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"Route not found. Make sure the URL and method are correct.\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t\tstatus: 404,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Parse body\n\tlet body: any;\n\ttry {\n\t\tbody = await req.json();\n\t} catch {\n\t\tconst output = {\n\t\t\tmessage: \"Request must have a valid JSON body.\",\n\t\t};\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n\n\ttry {\n\t\t// Call module\n\t\tconst output = await ctx.call(\n\t\t\tmoduleName as any,\n\t\t\tscriptName as any,\n\t\t\tbody,\n\t\t);\n\n\t\tif (output.__tempPleaseSeeOGBE3_NoData) {\n\t\t\treturn new Response(undefined, {\n\t\t\t\tstatus: 204,\n\t\t\t\theaders: {\n\t\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t} catch (error) {\n\t\t// Error response\n\t\tlet output;\n\t\tif (error instanceof RuntimeError) {\n\t\t\tctx.log.error(\n\t\t\t\t\"runtime error\",\n\t\t\t\t...errorToLogEntries(\"error\", error),\n\t\t\t);\n\t\t\toutput = {\n\t\t\t\tmessage: error.message,\n\t\t\t\ttrace: error.trace,\n\t\t\t};\n\t\t} else {\n\t\t\tctx.log.error(\"internal error\", [\"error\", error]);\n\t\t\toutput = {\n\t\t\t\tmessage: \"Internal error. More details have been printed in the logs.\",\n\t\t\t\ttrace: error.trace,\n\t\t\t};\n\t\t}\n\n\t\treturn new Response(JSON.stringify(output), {\n\t\t\tstatus: 500,\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t...runtime.corsHeaders(req),\n\t\t\t},\n\t\t});\n\t}\n}\n",
"src/runtime/trace.ts":"import { JsonObject } from \"../types/json.ts\";\nimport { UnreachableError } from \"./error.ts\";\nimport { BuildRuntime } from \"./runtime.ts\";\n\n/**\n * Provides context about where this script call came from.\n */\nexport interface Trace extends JsonObject {\n\trayId: string;\n\tentries: TraceEntry[];\n}\n\n/**\n * Single entry in the trace.\n */\nexport interface TraceEntry extends JsonObject {\n\trequestId: string;\n\tstartedAt: string;\n\ttype: TraceEntryType;\n}\n\n/**\n * Infomration about the type of the trace entry.\n */\nexport type TraceEntryType =\n\t| { httpRequest: TraceEntryTypeHttpRequest }\n\t| {\n\t\tscript: TraceEntryTypeScript;\n\t}\n\t| { actorInitialize: TraceEntryTypeActorInitialize }\n\t| { actorCall: TraceEntryTypeActorCall }\n\t| { actorSchedule: TraceEntryTypeActorSchedule }\n\t| { test: TraceEntryTypeTest }\n\t| { internalTest: TraceEntryTypeInternalTest };\n\nexport function stringifyTraceEntryType(trace: TraceEntryType) {\n\tif (\"httpRequest\" in trace) {\n\t\tconst { method, path } = trace.httpRequest;\n\t\treturn `httpRequest(${method} ${path})`;\n\t} else if (\"script\" in trace) {\n\t\tconst { module, script } = trace.script;\n\t\treturn `script(${module}.${script})`;\n\t} else if (\"actorInitialize\" in trace) {\n\t\tconst { module, actor } = trace.actorInitialize;\n\t\treturn `actorInitialize(${module}.${actor})`;\n\t} else if (\"actorCall\" in trace) {\n\t\tconst { module, actor, fn } = trace.actorCall;\n\t\treturn `actorCall(${module}.${actor}.${fn})`;\n\t} else if (\"actorSchedule\" in trace) {\n\t\treturn \"actorSchedule\";\n\t} else if (\"test\" in trace) {\n\t\tconst { module, name } = trace.test;\n\t\treturn `test(${module}.${name})`;\n\t} else if (\"internalTest\" in trace) {\n\t\treturn \"internalTest\";\n\t} else {\n\t\tthrow new UnreachableError(trace);\n\t}\n}\n\nexport interface TraceEntryTypeHttpRequest extends JsonObject {\n\tmethod: string;\n\tpath: string;\n\tremoteAddress: string;\n\theaders: { [key: string]: string };\n}\n\nexport interface TraceEntryTypeScript extends JsonObject {\n\tmodule: string;\n\tscript: string;\n}\n\nexport interface TraceEntryTypeActorInitialize extends JsonObject {\n\tmodule: string;\n\tactor: string;\n}\n\nexport interface TraceEntryTypeActorCall extends JsonObject {\n\tmodule: string;\n\tactor: string;\n\tfn: string;\n}\n\nexport interface TraceEntryTypeActorSchedule extends JsonObject {}\n\nexport interface TraceEntryTypeTest extends JsonObject {\n\tmodule: string;\n\tname: string;\n}\n\nexport interface TraceEntryTypeInternalTest extends JsonObject {\n}\n\nexport function newTrace(entryType: TraceEntryType, runtime: BuildRuntime = BuildRuntime.Deno): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\t// Read managed opengb ray id from request header (set by cloudflare)\n\tlet rayId: string;\n\tif (runtime == BuildRuntime.Cloudflare && \"httpRequest\" in entry) {\n\t\trayId = (entry.httpRequest as TraceEntryTypeHttpRequest).headers[\"x-opengb-ray-id\"];\n\t} else {\n\t\t// Generate random ray ID\n\t\trayId = crypto.randomUUID();\n\t}\n\n\treturn {\n\t\trayId,\n\t\tentries: [entry],\n\t};\n}\n\n/**\n * Returns a new trace with the given entry appended to it.\n */\nexport function appendTraceEntry(\n\ttrace: Trace,\n\tentryType: TraceEntryType,\n): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\treturn {\n\t\trayId: trace.rayId,\n\t\tentries: [...trace.entries, entry],\n\t};\n}\n",
"src/types/case_conversions.ts":"export function camelify(snake: string) {\n\treturn snake.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function pascalify(snake: string) {\n\tconst camel = camelify(snake);\n\treturn camel[0].toUpperCase() + camel.slice(1);\n}\n\nexport function snakeify(camel: string) {\n\treturn camel.replace(/[A-Z]/g, (g) => `_${g.toLowerCase()}`);\n}\n",
"src/types/expandable.ts":"export type Expandable<T> = string | T;\n",
"src/types/identifiers/defs.ts":"export enum Casing {\n\tSnake = \"snake_case\",\n\tScreamingSnake = \"SCREAMING_SNAKE_CASE\",\n}\n\n/**\n * A record of regular expressions for each identifier type.\n *\n * `regexes[identType].test(ident)` will return whether `ident` is a valid\n * `identType`.\n */\nexport const regexes: Record<Casing, RegExp> = {\n\t[Casing.Snake]: /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/,\n\t[Casing.ScreamingSnake]: /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/,\n};\n\n/**\n * A regular expression that matches a string of only printable ASCII\n * characters.\n *\n * Printable ASCII characters range from 0x20 to 0x7e, or space to tilde.\n */\nexport const printableAsciiRegex = /^[\\x20-\\x7E]+$/;\n",
"src/types/identifiers/deps.ts":"export { bold, brightRed } from \"https://deno.land/std@0.208.0/fmt/colors.ts\";\n",
"src/types/identifiers/errors.ts":"import { UserError, UserErrorOpts } from \"../../error/mod.ts\";\nimport { printableAsciiRegex } from \"./defs.ts\";\nimport { bold, brightRed } from \"./deps.ts\";\n\nexport class IdentifierError extends UserError {\n\tpublic constructor(private issue: string, private identifier: string, opts?: UserErrorOpts) {\n\t\tsuper(`\"${debugIdentifier(identifier)}\": ${issue}`, opts);\n\n\t\tthis.name = \"IdentifierError\";\n\t}\n\n\tpublic toString(identifierType = \"identifier\") {\n\t\tconst highlightedIdentifier = brightRed(bold(debugIdentifier(this.identifier)));\n\t\treturn `invalid ${identifierType} ${highlightedIdentifier}: ${this.issue}`;\n\t}\n}\n\n/**\n * Converts an identifier into a string that can be printed to the console.\n *\n * This function should be used when working with unverified\n * module/script/error names, as it is guaranteed it won't mess up the\n * terminal or obscure logging with control characters.\n *\n * Examples:\n * ```ts\n * IdentError.debugIdentifier(\"hello\") // \"hello\"\n * IdentError.debugIdentifier(\"hello\\x20world\") // \"hello world\"\n * IdentError.debugIdentifier(\"hello\\x7fworld\") // \"hello\\7fworld\"\n * IdentError.debugIdentifier(\"hello_wòrld\") // \"hello_w\\xf2rld\"\n *\n * @param ident The identifier to be converted into a safe debugged string\n * @returns A string containing all string-safe printable ascii characters, with\n * non-printable characters escaped as hex or unicode.\n */\nfunction debugIdentifier(ident: string): string {\n\tconst lenLimited = ident.length > 32 ? ident.slice(0, 32) + \"...\" : ident;\n\tconst characters = lenLimited.split(\"\");\n\n\tlet output = \"\";\n\tfor (const char of characters) {\n\t\t// If the character is printable without any special meaning, just\n\t\t// add it.\n\t\tif (printableAsciiRegex.test(char) && char !== \"\\\\\" && char !== '\"') {\n\t\t\toutput += char;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Escape `\\` and `\"` characters to reduce ambiguity\n\t\tif (char === \"\\\\\") {\n\t\t\toutput += \"\\\\\\\\\";\n\t\t\tcontinue;\n\t\t} else if (char === '\"') {\n\t\t\toutput += '\\\\\"';\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Escape non-printable characters\n\t\tconst charCode = char.charCodeAt(0);\n\t\tif (charCode > 255) { // 16-bit unicode escape\n\t\t\toutput += `\\\\u${charCode.toString(16).padStart(4, \"0\")}`;\n\t\t} else { // 8-bit ascii/extended-ascii escape\n\t\t\toutput += `\\\\x${charCode.toString(16).padStart(2, \"0\")}`;\n\t\t}\n\t}\n\treturn `\"${output}\"`;\n}\n",
"src/types/identifiers/mod.ts":"import { Casing, printableAsciiRegex, regexes } from \"./defs.ts\";\nimport { IdentifierError } from \"./errors.ts\";\n\nexport function validateIdentifier(\n\tident: string,\n\tidentType: Casing,\n) {\n\tif (ident.length < 1 || ident.length > 32) {\n\t\tthrow new IdentifierError(\"must be between 1 and 32 characters\", ident);\n\t}\n\n\tif (!printableAsciiRegex.test(ident)) {\n\t\tthrow new IdentifierError(\"must contain only printable ASCII characters\", ident);\n\t}\n\n\tconst regex = regexes[identType];\n\tif (!regex.test(ident)) {\n\t\tthrow new IdentifierError(`must be ${identType} (match the pattern ${regex})`, ident);\n\t}\n\n\treturn null;\n}\n",
"src/types/json.ts":"/**\n * A JSON type that can be clealy serialized to/from JSON.\n */\nexport declare type JsonValue =\n\t| string\n\t| number\n\t| boolean\n\t| JsonObject\n\t| JsonArray\n\t| null;\n\n/**\n * A JSON array that can be clealy serialized to/from JSON.\n */\nexport declare interface JsonArray extends Array<JsonValue> {\n}\n\n/**\n * A JSON object that can be clealy serialized to/from JSON.\n */\nexport declare type JsonObject = {\n\t[Key in string]?: JsonValue;\n};\n",
"src/types/registry.ts":"export type BaseRegistryBounds = Record<any, Record<any, { request: any; response: any }>>;\n\nexport type RequestOf<T> = T extends { request: any } ? T[\"request\"] : never;\nexport type ResponseOf<T> = T extends { response: any } ? T[\"response\"] : never;\n\nexport type DependencyScriptCallFunction<ThisType, Dependencies> = <\n\tM extends keyof Dependencies & string,\n\tS extends keyof Dependencies[M] & string,\n>(\n\tthis: ThisType,\n\tmodule: M,\n\tscript: S,\n\treq: RequestOf<Dependencies[M][S]>,\n) => Promise<ResponseOf<Dependencies[M][S]>>;\n",
"src/utils/db.ts":"const DEFAULT_DATABASE_URL = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\";\n\nexport function getDatabaseUrl(): URL {\n\treturn new URL(Deno.env.get(\"DATABASE_URL\") ?? DEFAULT_DATABASE_URL);\n}\n\n/**\n * Returns a database URL that includes the schema as a query parameter. Only\n * Prisma handles schemas passed in the URL.\n */\nexport function getPrismaDatabaseUrlWithSchema(dbName: string): URL {\n\tconst url = getDatabaseUrl();\n\turl.searchParams.set(\"schema\", dbName);\n\n\treturn url;\n}\n"
}