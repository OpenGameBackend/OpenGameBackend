{"src/deps.ts":"export { dirname, fromFileUrl, isAbsolute, relative, resolve, SEP } from \"https://deno.land/std@0.208.0/path/mod.ts\";\nexport { copy, emptyDir, exists, move } from \"https://deno.land/std@0.208.0/fs/mod.ts\";\nexport { parse, stringify } from \"https://deno.land/std@0.208.0/yaml/mod.ts\";\nexport { assert, assertEquals, assertExists } from \"https://deno.land/std@0.208.0/assert/mod.ts\";\n\nexport { fileURLToPath } from \"node:url\";\n\nexport * as tjs from \"npm:typescript-json-schema@^0.62.0\";\n\nimport Ajv from \"npm:ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"npm:ajv-formats@^2.1.1\";\nexport { addFormats };\n\nexport * as esbuild from \"https://deno.land/x/esbuild@v0.20.1/mod.js\";\nexport { denoPlugins } from \"https://deno.land/x/esbuild_deno_loader@0.8.5/mod.ts\";\n","src/utils/db.ts":"const DEFAULT_DATABASE_URL = \"postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable\";\n\nexport function getDatabaseUrl(dbName: string): URL {\n\tconst moduleDbUrl = Deno.env.get(`DATABASE_URL_${dbName}`);\n\n\tlet url;\n\tif (moduleDbUrl) {\n\t\turl = new URL(moduleDbUrl);\n\t} else {\n\t\t// Build URL for this database\n\t\turl = new URL(getDefaultDatabaseUrl());\n\t\turl.pathname = \"/\" + dbName;\n\t}\n\n\treturn url;\n}\n\nexport function getDefaultDatabaseUrl() {\n\treturn Deno.env.get(\"DATABASE_URL\") ?? DEFAULT_DATABASE_URL;\n}\n","src/runtime/trace.ts":"import { JsonObject } from \"../types/json.ts\";\n\n/**\n * Provides context about where this script call came from.\n */\nexport interface Trace extends JsonObject {\n\trayId: string;\n\tentries: TraceEntry[];\n}\n\n/**\n * Single entry in the trace.\n */\nexport interface TraceEntry extends JsonObject {\n\trequestId: string;\n\tstartedAt: string;\n\ttype: TraceEntryType;\n}\n\n/**\n * Infomration about the type of the trace entry.\n */\nexport type TraceEntryType =\n\t| { httpRequest: TraceEntryTypeHttpRequest }\n\t| {\n\t\tscript: TraceEntryTypeScript;\n\t}\n\t| { test: TraceEntryTypeTest }\n\t| { internalTest: TraceEntryTypeInternalTest };\n\nexport interface TraceEntryTypeHttpRequest extends JsonObject {\n\tmethod: string;\n\tpath: string;\n\tremoteAddress: string;\n\theaders: { [key: string]: string };\n}\n\nexport interface TraceEntryTypeScript extends JsonObject {\n\tmodule: string;\n\tscript: string;\n}\n\nexport interface TraceEntryTypeTest extends JsonObject {\n\tmodule: string;\n\tname: string;\n}\n\nexport interface TraceEntryTypeInternalTest extends JsonObject {\n}\n\nexport function newTrace(entryType: TraceEntryType): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\treturn {\n\t\trayId: crypto.randomUUID(),\n\t\tentries: [entry],\n\t};\n}\n\n/**\n * Returns a new trace with the given entry appended to it.\n */\nexport function appendTraceEntry(\n\ttrace: Trace,\n\tentryType: TraceEntryType,\n): Trace {\n\tconst entry: TraceEntry = {\n\t\trequestId: crypto.randomUUID(),\n\t\tstartedAt: new Date().toISOString(),\n\t\ttype: entryType,\n\t};\n\n\treturn {\n\t\trayId: trace.rayId,\n\t\tentries: [...trace.entries, entry],\n\t};\n}\n","src/runtime/server.ts":"import { Runtime } from \"./runtime.ts\";\n\nconst MODULE_CALL = /^\\/modules\\/(?<module>\\w+)\\/scripts\\/(?<script>\\w+)\\/call\\/?$/;\n\nexport function serverHandler<DependenciesSnakeT, DependenciesCamelT>(\n\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT>,\n): Deno.ServeHandler {\n\treturn async (\n\t\treq: Request,\n\t\tinfo: Deno.ServeHandlerInfo,\n\t): Promise<Response> => {\n\t\tconst url = new URL(req.url);\n\n\t\tconst matches = MODULE_CALL.exec(url.pathname);\n\t\tif (req.method == \"POST\" && matches?.groups) {\n\t\t\t// Lookup script\n\t\t\tconst moduleName = matches.groups.module;\n\t\t\tconst scriptName = matches.groups.script;\n\t\t\tconst script = runtime.config.modules[moduleName]?.scripts[scriptName];\n\n\t\t\tif (script?.public) {\n\t\t\t\t// Create context\n\t\t\t\tconst ctx = runtime.createRootContext({\n\t\t\t\t\thttpRequest: {\n\t\t\t\t\t\tmethod: req.method,\n\t\t\t\t\t\tpath: url.pathname,\n\t\t\t\t\t\tremoteAddress: info.remoteAddr.hostname,\n\t\t\t\t\t\theaders: Object.fromEntries(req.headers.entries()),\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\t// Parse body\n\t\t\t\tlet body;\n\t\t\t\ttry {\n\t\t\t\t\tbody = await req.json();\n\t\t\t\t} catch {\n\t\t\t\t\tconst output = {\n\t\t\t\t\t\tmessage: \"Request must have a valid JSON body.\",\n\t\t\t\t\t};\n\t\t\t\t\treturn new Response(JSON.stringify(output), {\n\t\t\t\t\t\tstatus: 400,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// Call module\n\t\t\t\t\tconst output = await ctx.call(\n\t\t\t\t\t\tmoduleName as any,\n\t\t\t\t\t\tscriptName as any,\n\t\t\t\t\t\tbody,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (output.__tempPleaseSeeOGBE3_NoData) {\n\t\t\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\t\t\tstatus: 204,\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new Response(JSON.stringify(output), {\n\t\t\t\t\t\tstatus: 200,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Error response\n\t\t\t\t\tconst output = {\n\t\t\t\t\t\tmessage: e.message,\n\t\t\t\t\t};\n\n\t\t\t\t\treturn new Response(JSON.stringify(output), {\n\t\t\t\t\t\tstatus: 500,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Not found response\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\t\"message\": \"Route not found. Make sure the URL and method are correct.\",\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t},\n\t\t\t\tstatus: 404,\n\t\t\t},\n\t\t);\n\t};\n}\n","src/runtime/deps.ts":"export { QueryClient, Transaction } from \"https://deno.land/x/postgres@v0.17.2/mod.ts\";\n\nimport * as Ajv from \"https://esm.sh/ajv@^8.12.0\";\nexport { Ajv };\n\nimport addFormats from \"https://esm.sh/ajv-formats@^2.1.1\";\nexport { addFormats };\n","src/runtime/error.ts":"import { ModuleContext } from \"./context.ts\";\nimport { Context } from \"./context.ts\";\nimport { ErrorConfig, Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\n\nexport interface RuntimeErrorOptions extends ErrorOptions {\n\tmeta?: any;\n}\n\nexport class RuntimeError extends Error {\n\t/**\n\t * The module this error originated from.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic moduleName?: string;\n\n\t/**\n\t * Call trace of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic trace?: Trace;\n\n\t/**\n\t * Config of the error.\n\t *\n\t * Will be undefined if the error is not enriched yet.\n\t */\n\tpublic errorConfig?: ErrorConfig;\n\n\t/**\n\t * Additional metadata of the error.\n\t */\n\tpublic meta?: ErrorConfig;\n\n\tpublic constructor(\n\t\tpublic readonly code: string,\n\t\toptions?: RuntimeErrorOptions,\n\t) {\n\t\tsuper(code, options);\n\t\tthis.meta = options?.meta;\n\t}\n\n\t/**\n\t * Called by `Context` when an error is caught.\n\t */\n\tpublic enrich<\n\t\tDependenciesSnakeT,\n\t\tDependenciesCamelT,\n\t\tCtx extends Context<DependenciesSnakeT, DependenciesCamelT>,\n\t>(runtime: Runtime<DependenciesSnakeT, DependenciesCamelT>, context: Ctx) {\n\t\t// Add context to error\n\t\tif (context instanceof ModuleContext) {\n\t\t\tthis.moduleName = context.moduleName;\n\t\t}\n\t\tthis.trace = context.trace;\n\n\t\t// Lookup error config\n\t\tif (this.moduleName) {\n\t\t\tconst errorConfig = runtime.config.modules[this.moduleName]\n\t\t\t\t?.errors[this.code];\n\t\t\tif (errorConfig) {\n\t\t\t\tthis.errorConfig = errorConfig;\n\t\t\t\tif (errorConfig.description) {\n\t\t\t\t\tthis.message = `${this.moduleName}[${this.code}]: ${errorConfig.description}\\nTrace: ${\n\t\t\t\t\t\tJSON.stringify(context.trace)\n\t\t\t\t\t}`;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Error config not found for ${this.code}`);\n\t\t\t}\n\t\t}\n\n\t\t// Build enriched message\n\t\tlet message = \"\";\n\t\tif (this.moduleName) {\n\t\t\tmessage += `${this.moduleName}[${this.code}]`;\n\t\t} else {\n\t\t\tmessage += this.code;\n\t\t}\n\t\tif (this.errorConfig?.description) {\n\t\t\tmessage += `: ${this.errorConfig.description}`;\n\t\t}\n\t\tmessage += `\\nTrace: ${JSON.stringify(this.trace)}`;\n\t\tthis.message = message;\n\t}\n}\n","src/runtime/proxy.ts":"import { Context } from \"../runtime/mod.ts\";\nimport { RequestOf, ResponseOf } from \"../types/registry.ts\";\n\ntype ModuleRegistryPair = readonly [string, string];\n\n/**\n * This type is used denote a map the key/value pairs of one registry to\n * another.\n * \n * \n * Example:\n * ```ts\n * type TestReg1 = {\n *   foo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     baz: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   fil: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   }\n * };\n * \n * type TestReg2 = {\n *   canonicalFoo: {\n *     bar: { request: FooBarRequest, response: FooBarResponse },\n *     bazScript: { request: FooBazRequest, response: FooBazResponse },\n *   },\n *   filMod: {\n *     qux: { request: FilQuxRequest, response: FilQuxResponse },\n *     cor: { request: FilCorRequest, response: FilCorResponse },\n *   },\n * };\n * \n * const map: RegistryCallMap<TestReg1, TestReg2> = {\n *   foo: {\n *     bar: [\"canonicalFoo\", \"bar\"],\n *     baz: [\"canonicalFoo\", \"bazScript\"],\n *   },\n *   fil: {\n *     qux: [\"filMod\", \"qux\"],\n *     cor: [\"filMod\", \"cor\"],\n *   },\n * };\n * ```\n * \n * This is used by the {@linkcode buildRegistryProxy} function to map the camel\n * case keys from `ctx.modules.<camelMod>.<camelScript>(data);` to an\n * equivalent call to `ctx.call(<snake_mod>, <snake_script>, data);`.\n */\nexport type RegistryCallMap = Record<string, Record<string, ModuleRegistryPair>>;\n\n/**\n * A callable registry is an object that describes the structure of\n * `ctx.modules`.\n * \n * If we have a registry like this:\n * - module `foo`\n *   - script `bar`\n *     - request type `BarRequest`\n *     - response type `BarResponse`\n *   - script `baz`\n *     - request type `BazRequest`\n *     - response type `BazResponse`\n * - module `fil`\n *   - script `qux`\n *     - request type `QuxRequest`\n *     - response type `QuxResponse`\n *   - script `cor`\n *     - request type `CorRequest`\n *     - response type `CorResponse`\n * \n * The callable registry would look like this:\n * ```ts\n * type CallableRegistry_TestReg = {\n *   foo: {\n *     bar: (req: BarRequest) => Promise<BarResponse>,\n *     baz: (req: BazRequest) => Promise<BazResponse>,\n *   },\n *   fil: {\n *     qux: (req: QuxRequest) => Promise<QuxResponse>,\n *     cor: (req: CorRequest) => Promise<CorResponse>,\n *   },\n * }\n * ```\n * \n * This is the type returned by the {@linkcode buildRegistryProxy} function.\n * \n * It is accessible to the user as `ctx.modules`.\n */\nexport type CallableDependencies<DependenciesT> = {\n\t[Mod in keyof DependenciesT]: {\n\t\t[Script in keyof DependenciesT[Mod]]: (\n\t\t\treq: RequestOf<DependenciesT[Mod][Script]>,\n\t\t) => Promise<ResponseOf<DependenciesT[Mod][Script]>>;\n\t};\n};\n\n/**\n * \n * @param ctx The {@link Context} object to use to call the scripts in\n * accessible modules\n * @param map A {@link MapFrom} object that describes how to map\n * `[module, script] pairs from a camelCase registry to a snake_case registry\n * @returns A {@link CallableDependencies} object that implements the \"syntax sugar\"\n * that used in the `ctx.modules.<script>.<name>()` pattern to call scripts\n * without the `ctx.call` function.\n */\nexport function buildRegistryProxy<DependenciesSnakeT, DependenciesCamelT>(\n\tctx: Context<DependenciesSnakeT, DependenciesCamelT>,\n\tdependenciesMapCamelToSnake: RegistryCallMap,\n): CallableDependencies<DependenciesCamelT> {\n\tconst handler = {\n\t\tget: (_target: unknown, camelCaseModuleKey: string) => {\n\t\t\tif (camelCaseModuleKey in dependenciesMapCamelToSnake) {\n\t\t\t\tconst camelToSnakeMapForModule = dependenciesMapCamelToSnake[camelCaseModuleKey];\n\n\t\t\t\treturn new Proxy(camelToSnakeMapForModule, {\n\t\t\t\t\tget: (_target: unknown, scriptProp: string) => {\n\t\t\t\t\t\tif (scriptProp in camelToSnakeMapForModule) {\n\t\t\t\t\t\t\tconst [snakeCaseModule, snakeCaseScript] = camelToSnakeMapForModule[scriptProp];\n\t\t\t\t\t\t\treturn (req: unknown) => {\n\t\t\t\t\t\t\t\treturn ctx.call(\n\t\t\t\t\t\t\t\t\tsnakeCaseModule as any,\n\t\t\t\t\t\t\t\t\tsnakeCaseScript as any,\n\t\t\t\t\t\t\t\t\treq as any,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t};\n\treturn new Proxy({}, handler) as CallableDependencies<DependenciesCamelT>;\n}\n","src/runtime/runtime.ts":"import { addFormats, Ajv } from \"./deps.ts\";\nimport { ScriptContext } from \"./context.ts\";\nimport { Context, TestContext } from \"./context.ts\";\nimport { Postgres, PrismaClientDummy } from \"./postgres.ts\";\nimport { serverHandler } from \"./server.ts\";\nimport { TraceEntryType } from \"./trace.ts\";\nimport { newTrace } from \"./trace.ts\";\nimport { RegistryCallMap } from \"./proxy.ts\";\n\nexport interface Config {\n\tmodules: Record<string, Module>;\n}\n\nexport interface Module {\n\tscripts: Record<string, Script>;\n\terrors: Record<string, ErrorConfig>;\n\tdb?: {\n\t\tname: string;\n\t\tcreatePrisma: (databaseUrl: string) => CreatePrismaOutput;\n\t};\n\tdependencies: Set<string>;\n\tuserConfig: unknown;\n}\n\ninterface CreatePrismaOutput {\n\tprisma: PrismaClientDummy;\n\tpgPool?: any;\n}\n\nexport interface Script {\n\t// deno-lint-ignore no-explicit-any\n\trun: ScriptRun<any, any, any, any>;\n\t// deno-lint-ignore no-explicit-any\n\trequestSchema: any;\n\t// deno-lint-ignore no-explicit-any\n\tresponseSchema: any;\n\tpublic: boolean;\n}\n\nexport type ScriptRun<Req, Res, UserConfigT, DatabaseT> = (\n\tctx: ScriptContext<any, any, UserConfigT, DatabaseT>,\n\treq: Req,\n) => Promise<Res>;\n\nexport interface ErrorConfig {\n\tdescription?: string;\n}\n\nexport class Runtime<DependenciesSnakeT, DependenciesCamelT> {\n\tpublic postgres: Postgres;\n\n\tpublic ajv: Ajv.default;\n\n\tpublic constructor(public config: Config, private dependencyCaseConversionMap: RegistryCallMap) {\n\t\tthis.postgres = new Postgres();\n\n\t\tthis.ajv = new Ajv.default({\n\t\t\tremoveAdditional: true,\n\t\t});\n\t\t// TODO: Why are types incompatible\n\t\taddFormats.default(this.ajv as any);\n\t}\n\n\tprivate async shutdown() {\n\t\tawait this.postgres.shutdown();\n\t}\n\n\tpublic createRootContext(traceEntryType: TraceEntryType): Context<DependenciesSnakeT, DependenciesCamelT> {\n\t\treturn new Context(this, newTrace(traceEntryType), this.dependencyCaseConversionMap);\n\t}\n\n\t/**\n\t * Serves the runtime as an HTTP server.\n\t */\n\tpublic async serve() {\n\t\tconst port = parseInt(Deno.env.get(\"PORT\") ?? \"8080\");\n\t\tconsole.log(`Serving on port ${port}`);\n\t\tawait Deno.serve({ port }, serverHandler(this)).finished;\n\t}\n\n\t/**\n\t * Registers a module test with the Deno runtime.\n\t */\n\tpublic static test<DependenciesSnakeT, DependenciesCamelT, UserConfigT>(\n\t\tconfig: Config,\n\t\tmoduleName: string,\n\t\ttestName: string,\n\t\tfn: (ctx: TestContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, any>) => Promise<void>,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tDeno.test({\n\t\t\tname: testName,\n\n\t\t\t// TODO: https://github.com/rivet-gg/opengb-engine/issues/35\n\t\t\tsanitizeOps: false,\n\t\t\tsanitizeResources: false,\n\n\t\t\tasync fn() {\n\t\t\t\tconst runtime = new Runtime<DependenciesSnakeT, DependenciesCamelT>(config, dependencyCaseConversionMap);\n\n\t\t\t\t// Build context\n\t\t\t\tconst module = config.modules[moduleName];\n\t\t\t\tconst ctx = new TestContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, PrismaClientDummy | undefined>(\n\t\t\t\t\truntime,\n\t\t\t\t\tnewTrace({\n\t\t\t\t\t\ttest: { module: moduleName, name: testName },\n\t\t\t\t\t}),\n\t\t\t\t\tmoduleName,\n\t\t\t\t\truntime.postgres.getOrCreatePool(module)?.prisma,\n\t\t\t\t\tdependencyCaseConversionMap,\n\t\t\t\t);\n\n\t\t\t\t// Run test\n\t\t\t\ttry {\n\t\t\t\t\tawait ctx.runBlock(async () => {\n\t\t\t\t\t\tawait fn(ctx);\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`Failed to execute test: ${moduleName}.${testName}`,\n\t\t\t\t\t\tcause,\n\t\t\t\t\t);\n\t\t\t\t\tthrow cause;\n\t\t\t\t} finally {\n\t\t\t\t\tawait runtime.shutdown();\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n","src/runtime/context.ts":"import { Runtime } from \"./runtime.ts\";\nimport { Trace } from \"./trace.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { appendTraceEntry } from \"./trace.ts\";\nimport { buildRegistryProxy, RegistryCallMap } from \"./proxy.ts\";\nimport { DependencyScriptCallFunction } from \"../types/registry.ts\";\n\nexport class Context<DependenciesSnakeT, DependenciesCamelT> {\n\tpublic constructor(\n\t\tprotected readonly runtime: Runtime<DependenciesSnakeT, DependenciesCamelT>,\n\t\tpublic readonly trace: Trace,\n\t\tprivate readonly dependencyCaseConversionMap: RegistryCallMap,\n\t) {}\n\n\tprotected isAllowedModuleName(_moduleName: string): boolean {\n\t\treturn true;\n\t}\n\n\tpublic call: DependencyScriptCallFunction<this, DependenciesSnakeT> = async function (\n\t\tmoduleName,\n\t\tscriptName,\n\t\treq,\n\t) {\n\t\tconsole.log(\n\t\t\t`Request ${moduleName}.${scriptName}:\\n${JSON.stringify(req, null, 2)}`,\n\t\t);\n\n\t\ttry {\n\t\t\t// Check if calling module is allowed to call target module\n\t\t\tif (!this.isAllowedModuleName(moduleName)) {\n\t\t\t\tthrow new RuntimeError(\n\t\t\t\t\t\"CANNOT_ACCESS_MODULE\",\n\t\t\t\t\t{ cause: `Module \\`${moduleName}\\` is not a dependency` },\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Lookup module\n\t\t\tconst module = this.runtime.config.modules[moduleName];\n\t\t\tif (!module) throw new Error(`Module not found: ${moduleName}`);\n\n\t\t\t// Lookup script\n\t\t\tconst script = module.scripts[scriptName];\n\t\t\tif (!script) throw new Error(`Script not found: ${scriptName}`);\n\n\t\t\t// Build context\n\t\t\tconst ctx = new ScriptContext(\n\t\t\t\tthis.runtime,\n\t\t\t\tappendTraceEntry(this.trace, {\n\t\t\t\t\tscript: { module: moduleName, script: scriptName },\n\t\t\t\t}),\n\t\t\t\tmoduleName,\n\t\t\t\tthis.runtime.postgres.getOrCreatePool(module)?.prisma,\n\t\t\t\tscriptName,\n\t\t\t\tthis.dependencyCaseConversionMap,\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Compile schemas\n\t\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t\t// const validateResponse = this.runtime.ajv.compile(script.responseSchema);\n\n\t\t\t// // Validate request\n\t\t\t// if (!validateRequest(req)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid request: ${JSON.stringify(validateRequest.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\t// Execute script\n\t\t\tconst res = await ctx.runBlock(async () => await script.run(ctx, req));\n\t\t\tconsole.log(\n\t\t\t\t`Response ${moduleName}.${scriptName}:\\n${JSON.stringify(res, null, 2)}`,\n\t\t\t);\n\n\t\t\t// TODO: Replace with OGBE-15\n\t\t\t// // Validate response\n\t\t\t// if (!validateResponse(res)) {\n\t\t\t// \tthrow new Error(\n\t\t\t// \t\t`Invalid response: ${JSON.stringify(validateResponse.errors)}`,\n\t\t\t// \t);\n\t\t\t// }\n\n\t\t\treturn res as any;\n\t\t} catch (cause) {\n\t\t\tconsole.warn(\n\t\t\t\t`Failed to execute script: ${moduleName}.${scriptName}`,\n\t\t\t\tcause,\n\t\t\t);\n\t\t\tthrow cause;\n\t\t}\n\t};\n\n\tpublic get modules() {\n\t\treturn buildRegistryProxy<DependenciesSnakeT, DependenciesCamelT>(\n\t\t\tthis,\n\t\t\tthis.dependencyCaseConversionMap,\n\t\t);\n\t}\n\n\tpublic async tryCallRaw(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\treq: unknown,\n\t): Promise<object | null> {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return null;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return null;\n\n\t\treturn await this.call(moduleName as any, scriptName as any, req as any);\n\t}\n\n\tpublic canCall(\n\t\tmoduleName: string,\n\t\tscriptName: string,\n\t\t_req?: unknown,\n\t): boolean {\n\t\t// Lookup module\n\t\tconst module = this.runtime.config.modules[moduleName];\n\t\tif (!module) return false;\n\n\t\t// Lookup script\n\t\tconst script = module.scripts[scriptName];\n\t\tif (!script) return false;\n\n\t\t// TODO: Replace with OGBE-15\n\t\t// const validateRequest = this.runtime.ajv.compile(script.requestSchema);\n\t\t// if (req && !validateRequest(req)) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Runs a block of code and catches any related errors.\n\t */\n\tpublic async runBlock<Res>(fn: () => Promise<Res>) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (cause) {\n\t\t\t// Convert error to RuntimeError. Enrich with context.\n\t\t\tif (cause instanceof RuntimeError) {\n\t\t\t\tcause.enrich(this.runtime, this);\n\t\t\t\tthrow cause;\n\t\t\t} else {\n\t\t\t\tconst error = new RuntimeError(\"INTERNAL_ERROR\", { cause });\n\t\t\t\terror.enrich(this.runtime, this);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Context for a module.\n */\nexport class ModuleContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, DatabaseT>\n\textends Context<DependenciesSnakeT, DependenciesCamelT> {\n\tpublic constructor(\n\t\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT>,\n\t\ttrace: Trace,\n\t\tpublic readonly moduleName: string,\n\t\tpublic readonly db: DatabaseT,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, dependencyCaseConversionMap);\n\t}\n\n\tprotected isAllowedModuleName(targetModuleName: string): boolean {\n\t\treturn this.runtime.config\n\t\t\t.modules[this.moduleName]\n\t\t\t?.dependencies\n\t\t\t.has(targetModuleName);\n\t}\n\n\tpublic get userConfig(): UserConfigT {\n\t\treturn this.runtime.config.modules[this.moduleName].userConfig as UserConfigT;\n\t}\n}\n\n/**\n * Context for a script.\n */\nexport class ScriptContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, DatabaseT>\n\textends ModuleContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, DatabaseT> {\n\tpublic constructor(\n\t\truntime: Runtime<DependenciesSnakeT, DependenciesCamelT>,\n\t\ttrace: Trace,\n\t\tmoduleName: string,\n\t\tdb: DatabaseT,\n\t\tpublic readonly scriptName: string,\n\t\tdependencyCaseConversionMap: RegistryCallMap,\n\t) {\n\t\tsuper(runtime, trace, moduleName, db, dependencyCaseConversionMap);\n\t}\n}\n\n/**\n * Context for a test.\n */\nexport class TestContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, DatabaseT>\n\textends ModuleContext<DependenciesSnakeT, DependenciesCamelT, UserConfigT, DatabaseT> {}\n","src/runtime/postgres.ts":"import { QueryClient, Transaction } from \"./deps.ts\";\nimport { Module } from \"./runtime.ts\";\nimport { getDatabaseUrl } from \"../utils/db.ts\";\n\ntype PostgresRunScope<T> = (conn: QueryClient) => Promise<T>;\ntype PostgresTransactionScope<T> = (conn: Transaction) => Promise<T>;\n\nexport interface PrismaClientDummy {\n\t$disconnect(): Promise<void>;\n}\n\nexport interface Pool {\n\tprisma: PrismaClientDummy;\n\tpgPool?: any;\n}\n\n/** Manages Postgres connections. */\nexport class Postgres {\n\tprivate isShutDown = false;\n\n\tpublic pools = new Map<string, Pool>();\n\n\tpublic async shutdown() {\n\t\tthis.isShutDown = true;\n\t\tfor (const pool of this.pools.values()) {\n\t\t\tawait pool.prisma.$disconnect();\n\t\t\tif (pool.pgPool) await pool.pgPool.end();\n\t\t}\n\t}\n\n\tpublic getOrCreatePool(module: Module): Pool | undefined {\n\t\tif (!module.db) return undefined;\n\t\tif (this.isShutDown) throw new Error(\"Postgres is shutting down\");\n\n\t\tif (this.pools.has(module.db.name)) {\n\t\t\treturn this.pools.get(module.db.name)!;\n\t\t} else {\n\t\t\tconst url = getDatabaseUrl(module.db.name);\n\n\t\t\t// Create & insert pool\n\t\t\tconst output = module.db.createPrisma(url.toString());\n\t\t\tconst pool = {\n\t\t\t\tprisma: output.prisma,\n\t\t\t\tpgPool: output.pgPool,\n\t\t\t} as Pool;\n\t\t\tthis.pools.set(module.db.name, pool);\n\t\t\treturn pool;\n\t\t}\n\t}\n}\n\n/** Dummy type to represent places where we reference a specific database. */\nexport type PostgresWrapped<T> = T;\n","src/runtime/mod.ts":"export * from \"./context.ts\";\nexport * from \"./runtime.ts\";\nexport * from \"./trace.ts\";\nexport * from \"./error.ts\";\n","src/runtime/error_test.ts":"import { assertEquals, assertExists } from \"../deps.ts\";\nimport { ModuleContext } from \"./context.ts\";\nimport { RuntimeError } from \"./error.ts\";\nimport { newTrace } from \"./mod.ts\";\nimport { Runtime } from \"./runtime.ts\";\n\ntype ErrReg = { test_module: Record<string, never> };\ntype ErrRegCamel = { testModule: Record<string, never> };\n\nDeno.test(\"error\", async () => {\n\tconst camelMap = {\n\t\ttestModule: {},\n\t} as const;\n\t// Setup\n\tconst runtime = new Runtime<ErrReg, ErrRegCamel>({\n\t\tmodules: {\n\t\t\ttest_module: {\n\t\t\t\tscripts: {},\n\t\t\t\terrors: {\n\t\t\t\t\t\"TEST_ERROR\": {},\n\t\t\t\t},\n\t\t\t\tdependencies: new Set([\"test_module\"]),\n\t\t\t\tuserConfig: null,\n\t\t\t},\n\t\t},\n\t}, camelMap);\n\tconst moduleContext = new ModuleContext<ErrReg, ErrRegCamel, null, undefined>(\n\t\truntime,\n\t\tnewTrace({ internalTest: {} }),\n\t\t\"test_module\",\n\t\tundefined,\n\t\tcamelMap,\n\t);\n\n\t// Create error\n\tconst error = new RuntimeError(\"TEST_ERROR\");\n\tassertEquals(error.message.split(\"\\n\")[0], \"TEST_ERROR\");\n\n\t// Erich error\n\terror.enrich(runtime, moduleContext);\n\tassertExists(error.moduleName);\n\tassertExists(error.trace);\n\tassertExists(error.errorConfig);\n\tassertEquals(error.message.split(\"\\n\")[0], \"test_module[TEST_ERROR]\");\n});\n","src/types/registry.ts":"export type BaseRegistryBounds = Record<any, Record<any, { request: any; response: any }>>;\n\nexport type RequestOf<T> = T extends { request: any } ? T[\"request\"] : never;\nexport type ResponseOf<T> = T extends { response: any } ? T[\"response\"] : never;\n\nexport type DependencyScriptCallFunction<ThisType, Dependencies> = <\n\tM extends keyof Dependencies & string,\n\tS extends keyof Dependencies[M] & string,\n>(\n\tthis: ThisType,\n\tmodule: M,\n\tscript: S,\n\treq: RequestOf<Dependencies[M][S]>,\n) => Promise<ResponseOf<Dependencies[M][S]>>;\n","src/types/case_conversions.ts":"export function camelify(snake: string) {\n\treturn snake.replace(/_([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function pascalify(snake: string) {\n\tconst camel = camelify(snake);\n\treturn camel[0].toUpperCase() + camel.slice(1);\n}\n\nexport function snakeify(camel: string) {\n\treturn camel.replace(/[A-Z]/g, (g) => `_${g.toLowerCase()}`);\n}\n","src/types/json.ts":"/**\n * A JSON type that can be clealy serialized to/from JSON.\n */\nexport declare type JsonValue =\n\t| string\n\t| number\n\t| boolean\n\t| JsonObject\n\t| JsonArray\n\t| null;\n\n/**\n * A JSON array that can be clealy serialized to/from JSON.\n */\nexport declare interface JsonArray extends Array<JsonValue> {\n}\n\n/**\n * A JSON object that can be clealy serialized to/from JSON.\n */\nexport declare type JsonObject = {\n\t[Key in string]?: JsonValue;\n};\n","src/types/expandable.ts":"export type Expandable<T> = string | T;\n"}