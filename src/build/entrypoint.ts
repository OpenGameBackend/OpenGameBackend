import { join } from "../deps.ts";
import { Project } from "../project/mod.ts";
import { genRuntimeModPath } from "../project/project.ts";

export async function generateEntrypoint(project: Project) {
	const runtimePath = genRuntimeModPath(project);

	// Generate module configs
	let modImports = "";
	let modConfig = "{";
	for (const mod of project.modules.values()) {
		modConfig += `${JSON.stringify(mod.name)}: {`;

		// Generate script configs
		modConfig += "scripts: {";
		for (const script of mod.scripts.values()) {
			const runIdent = `modules$$${mod.name}$$${script.name}$$run`;

			modImports +=
				`import { run as ${runIdent} } from '${mod.path}/scripts/${script.name}.ts';\n`;

			modConfig += `${JSON.stringify(script.name)}: {`;
			modConfig += `run: ${runIdent},`;
			modConfig += `public: ${JSON.stringify(script.config.public ?? false)},`;
			modConfig += `requestSchema: ${JSON.stringify(script.requestSchema)},`;
			modConfig += `responseSchema: ${JSON.stringify(script.responseSchema)},`;
			modConfig += `},`;
		}
		modConfig += "},";

		// Generate error configs
		modConfig += `errors: ${JSON.stringify(mod.config.errors)},`;

		// Generate dependency lookup
		modConfig += `dependencies: new Set([`;
		modConfig += JSON.stringify(mod.name) + ",";
		for (const dependencyName in mod.config.dependencies) {
			modConfig += JSON.stringify(dependencyName) + ",";
		}
		modConfig += `]),`;

		// Generate db config
		if (mod.db) {
			const prismaImportName = `prisma$$${mod.name}`;
			const prismaImportPath = `${mod.path}/_gen/prisma/esm.js`;
			modImports += `import ${prismaImportName} from "${prismaImportPath}";\n`;

			modConfig += `db: {`;
			modConfig += `name: ${JSON.stringify(mod.db.name)},`;
			modConfig += `createPrisma: (url: string) => {
				const pgPool = new pg.Pool({ connectionString: url })
				const adapter = new PrismaPg(pgPool);
				const prisma = new ${prismaImportName}.PrismaClient({
					adapter,
					log: ['query', 'info', 'warn', 'error'],
				});
				return { prisma, pgPool };
			},`;
			modConfig += `},`;
		} else {
			modConfig += `db: undefined,`;
		}

		modConfig += "},";
	}
	modConfig += "}";

	// Generate config.ts
	const configSource = `
// This file is generated by Open Game Backend engine

import { Config } from "${runtimePath}";

// Create module for Prisma compatability
import { createRequire } from "node:module";
const require = createRequire(import.meta.url);

// Import Prisma adapter for Postgres
import pg from "npm:pg@^8.11.3";
import { PrismaPg } from "npm:@prisma/adapter-pg@^5.9.1";

${modImports}

export default {
    modules: ${modConfig},
} as Config;

`;

	// Generate entrypoint.ts
	const entrypointSource = `
// This file is generated by Open Game Backend engine

import { Runtime } from "${runtimePath}";
import config from "./runtime_config.ts";

async function main() {
    const runtime = new Runtime(config);
    await runtime.serve();
}

main();

`;

	// Write file
	const distDir = join(project.path, "_gen");
	const configPath = join(distDir, "runtime_config.ts");
	const entrypointPath = join(distDir, "entrypoint.ts");
	await Deno.mkdir(distDir, { recursive: true });
	await Deno.writeTextFile(configPath, configSource);
	await Deno.writeTextFile(entrypointPath, entrypointSource);
	await Deno.writeTextFile(
		join(distDir, ".gitignore"),
		".",
	);

	// Format files
	const { success } = await new Deno.Command("deno", {
		args: ["fmt", configPath, entrypointPath],
	}).output();
	if (!success) throw new Error(`Failed to format generated files`);
}
