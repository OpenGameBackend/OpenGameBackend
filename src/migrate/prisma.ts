import { copy, resolve } from "../deps.ts";
import { dedent } from "./deps.ts";
import { Module, Project } from "../project/mod.ts";
import { CommandError, UserError } from "../error/mod.ts";
import { verbose } from "../term/status.ts";
import { createOnce, getOrInitOnce } from "../utils/once.ts";
import { genPath, PRISMA_WORKSPACE_PATH, RUNTIME_PATH } from "../project/project.ts";
import prismaArchive from "../../artifacts/prisma_archive.json" with { type: "json" };
import { inflateArchive } from "../build/util.ts";

export const PRISMA_VERSION = "5.15.0";

function getPrismaDir(project: Project) {
	return genPath(project, PRISMA_WORKSPACE_PATH);
}

const PRISMA_WORKSPACE_ONCE = createOnce<void>();

/**
 * Installs a copy of Prisma in to a directory that can be reused for any
 * Prisma-related commands.
 */
async function ensurePrismaWorkspace(project: Project): Promise<void> {
	return await getOrInitOnce(PRISMA_WORKSPACE_ONCE, async () => {
		return await ensurePrismaWorkspaceInner(project);
	});
}

async function ensurePrismaWorkspaceInner(project: Project): Promise<void> {
	const prismaDir = getPrismaDir(project);
	verbose("Setting up Prisma workspace", prismaDir);

	await Deno.mkdir(prismaDir, { recursive: true });

	verbose("Prisma workspace init complete", prismaDir);
}

export interface RunPrismaCommandOpts {
	args: string[];
	env: Record<string, string>;
	interactive: boolean;
	output: boolean;
	signal?: AbortSignal;
}
/**
 * Run a Prisma command in the Prisma workspace. The CWD is set to the `db`
 * directory.
 *
 * We don't use `deno run npm:prisma` because:
 *
 * - We already have Prisma installed in the workspace
 * - There are minor bugs with Deno's compatibility with Prisma
 */

export async function runPrismaCommand(
	project: Project,
	module: Module,
	opts: RunPrismaCommandOpts,
): Promise<string> {
	await ensurePrismaWorkspace(project);

	// Validate terminal
	if (opts.interactive && !Deno.stdin.isTerminal()) {
		throw new UserError("Cannot run this command without a terminal.", {
			suggest:
				"This is likely because you're running from a non-interactive shell, such as a CI environment. Run this command in a terminal that supports TTY.",
		});
	}

	const signal = opts.signal;

	// Unique isolated folder for this command to run in. This runs in the Prisma
	// workspace where Prisma is already installed.
	const prismaDir = getPrismaDir(project);
	const workspaceId = crypto.randomUUID();
	const dbDir = resolve(prismaDir, "db", workspaceId);
	await Deno.mkdir(dbDir, { recursive: true });
	verbose("Setting up Prisma command dir", dbDir);

	// Writes a copy of the OpenGB runtime bundled with the CLI to the project.
	const inflatePrismaPath = resolve(dbDir, "node_modules");
	await Deno.mkdir(inflatePrismaPath);
	await inflateArchive(prismaArchive, inflatePrismaPath, signal);

	// Copy database
	await copy(resolve(module.path, "db"), dbDir, { overwrite: true });

	// Append generator config
	const schemaPath = resolve(dbDir, "schema.prisma");
	let schema = await Deno.readTextFile(schemaPath);
	schema += dedent`
		// Generated by Open Game Backend
		generator client {
			provider = "prisma-client-js"
			output = "${dbDir}/client"
			previewFeatures = ["driverAdapters"]
		}
	`;
	await Deno.writeTextFile(schemaPath, schema);

	if (Deno.env.get("VERBOSE")) opts.env.DEBUG = "*";

	// Disable Prisma features
	opts.env.PRISMA_HIDE_UPDATE_MESSAGE = "binary";

	// Disable dependency on NodeJS
	//
	// We archive the node modules and inflate them manually. See `build_prisma_archive.ts`.
	opts.env.PRISMA_GENERATE_SKIP_AUTOINSTALL = "true";
	opts.env.PRISMA_SKIP_POSTINSTALL_GENERATE = "true";

	// Force binary since running Prisma in Deno doesn't work with Node dylibs
	opts.env.PRISMA_CLI_QUERY_ENGINE_TYPE = "binary";

	// Run the command
	verbose("Running Prisma command", `${dbDir}: prisma ${opts.args.join(" ")}`);
	const prismaOutput = await new Deno.Command("deno", {
		args: [
			"run",
			"-A",
			`npm:prisma@${PRISMA_VERSION}`,
			...opts.args,
		],
		cwd: dbDir,
		stdin: opts.interactive ? "inherit" : undefined,
		stdout: opts.output ? "inherit" : undefined,
		stderr: opts.output ? "inherit" : undefined,
		env: opts.env,
		signal,
	}).output();
	if (!prismaOutput.success) {
		throw new CommandError(`Failed to run: prisma ${opts.args.join(" ")}`, { commandOutput: prismaOutput });
	}

	// TODO: Clean up the workspace?
	return dbDir;
}
