import {
	Module,
	Registry,
	Script,
	scriptDistHelperPath,
} from "../registry/mod.ts";
import * as path from "std/path/mod.ts";
import {
	moduleDistHelperPath,
	testDistHelperPath,
} from "../registry/registry.ts";

export async function compileScriptHelpers(registry: Registry) {
	for (const module of registry.modules.values()) {
		await compileModuleHelper(registry, module);
		await compileTestHelper(registry, module);

		for (const script of module.scripts.values()) {
			await compileScriptHelper(registry, module, script);
		}
	}

	await compileTypeHelpers(registry);
}

async function compileModuleHelper(
	registry: Registry,
	module: Module,
) {
	console.log("Generating module", module.path);

	// Generate source
	const source = `
import { ModuleContext as ModuleContextInner } from "@ogs/runtime";
${
		module.db
			? `
import prisma from "../../prisma/${module.name}/esm.js";
export { prisma };
export const Prisma = prisma.Prisma;
`
			: ""
	}

export { RuntimeError } from "@ogs/runtime";

export type ModuleContext = ModuleContextInner<${
		module.db ? "prisma.PrismaClient" : "undefined"
	}>;
`;

	// Write source
	const helperPath = moduleDistHelperPath(registry, module);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileTestHelper(
	registry: Registry,
	module: Module,
) {
	console.log("Generating test", module.path);

	// Generate source
	const source = `
import * as module from "./mod.ts";
import { Runtime, TestContext as TestContextInner } from "@ogs/runtime";
import config from "../../../dist/runtime_config.ts";

export * from "./mod.ts";

export type TestContext = TestContextInner<${
		module.db ? "module.prisma.PrismaClient" : "undefined"
	}>;

export type TestFn = (ctx: TestContext) => Promise<void>;

export function test(name: string, fn: TestFn) {
	Runtime.test(config, "${module.name}", name, fn);
}
`;

	// Write source
	const helperPath = testDistHelperPath(registry, module);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileScriptHelper(
	registry: Registry,
	module: Module,
	script: Script,
) {
	console.log("Generating script", script.path);

	// Generate source
	const source = `
import * as module from "../mod.ts";
import { ScriptContext as ScriptContextInner } from "@ogs/runtime";
${
		module.db
			? `import { PrismaClient } from "../../../prisma/${module.name}/index.d.ts";`
			: ""
	}

export * from "../mod.ts";

export type ScriptContext = ScriptContextInner<${
		module.db ? "module.prisma.PrismaClient" : "undefined"
	}>;
`;

	// Write source
	const helperPath = scriptDistHelperPath(registry, module, script);
	await Deno.mkdir(path.dirname(helperPath), { recursive: true });
	await Deno.writeTextFile(helperPath, source);
}

async function compileTypeHelpers(registry: Registry) {
	const typedefPath = path.join(
		registry.path,
		"dist",
		"helpers",
		"registry.d.ts"
	);

	const modules: string[] = [];

	for (const module of registry.modules.values()) {
		const scripts: string[] = [];

		const moduleInterfaceName = `${module.name}Module`;
		for (const script of module.scripts.values()) {
			const scriptId = `${module.name}$$${script.name}`;

			const requestTypeName = `${scriptId}Req`;
			const responseTypeName = `${scriptId}Res`;

			const absoluteImportPath = path.join(registry.path, "modules", module.name, "scripts", `${script.name}.ts`);
			const importPath = path.relative(path.dirname(typedefPath), absoluteImportPath);

			const pathComment = `// ${module.name}/${script.name}`;
			const importLine = `import type { Request as ${requestTypeName}, Response as ${responseTypeName} } from ${JSON.stringify(importPath)};`;

			const interfaceDef = [
				`interface ${moduleInterfaceName} {`,
				`\t${script.name}: {`,
				`\t\trequest: ${requestTypeName};`,
				`\t\tresponse: ${responseTypeName};`,
				`\t};`,
				`}`,
			].join("\n");

			scripts.push([pathComment, importLine, interfaceDef].join("\n"));
		}

		const moduleComment = `//\n// Types for ${module.name}\n//`;
		const scriptBody = scripts.join("\n\n");

		const interfaceDef = `interface Registry {\n\t${module.name}: ${moduleInterfaceName};\n}`;

		modules.push([moduleComment, scriptBody, interfaceDef].join("\n"));
	}


	const source = `${autoGeneratedHeader.trim()}}\n\n${modules.join("\n\n\n\n")}\n\n${registryTypes.trim()}`;
	await Deno.mkdir(path.dirname(typedefPath), { recursive: true });
	await Deno.writeTextFile(typedefPath, source);
}

const autoGeneratedHeader = `
// This file is auto-generated by the OGS build system.
// Do not edit this file directly.
`;

const registryTypes = `
export type RequestOf<T> = T extends { request: any } ? T["request"] : never;
export type ResponseOf<T> = T extends { response: any } ? T["response"] : never;

export type RegistryCallFn<ThisType> = <M extends keyof Registry & string, S extends keyof Registry[M] & string>(
	this: ThisType,
	module: M,
	script: S,
	req: RequestOf<Registry[M][S]>,
) => Promise<ResponseOf<Registry[M][S]>>;`;
